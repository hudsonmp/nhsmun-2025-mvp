"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/context/AuthContext.tsx":
/*!*************************************!*\
  !*** ./lib/context/AuthContext.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: function() { return /* binding */ AuthProvider; },\n/* harmony export */   useAuth: function() { return /* binding */ useAuth; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/api */ \"(app-pages-browser)/./lib/api.ts\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n/* harmony import */ var _lib_googleDrive__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/googleDrive */ \"(app-pages-browser)/./lib/googleDrive.ts\");\n/* __next_internal_client_entry_do_not_use__ useAuth,AuthProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n// Create the context with a default value\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    isAuthenticated: false,\n    user: null,\n    session: null,\n    loading: true,\n    login: async ()=>null,\n    register: async ()=>null,\n    logout: async ()=>{},\n    checkAuth: async ()=>false,\n    // Google Drive authentication defaults\n    isGoogleDriveAuthenticated: false,\n    isGoogleDriveLoading: false,\n    authenticateGoogleDrive: async ()=>false,\n    initializeGoogleDrive: async ()=>{}\n});\n// Custom hook to use the auth context\nconst useAuth = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst AuthProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const [isAuthenticated, setIsAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [session, setSession] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Google Drive state\n    const [isGoogleDriveAuthenticated, setIsGoogleDriveAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isGoogleDriveLoading, setIsGoogleDriveLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isGoogleDriveInitialized, setIsGoogleDriveInitialized] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    // Initialize authentication state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const initAuth = async ()=>{\n            setLoading(true);\n            try {\n                // Get the current session from Supabase\n                const { data: { session } } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_4__.supabase.auth.getSession();\n                if (session) {\n                    setSession(session);\n                    setUser(session.user);\n                    setIsAuthenticated(true);\n                    console.log(\"Auth initialized from Supabase session\");\n                    // Initialize Google Drive when user is authenticated\n                    if (!isGoogleDriveInitialized) {\n                        initializeGoogleDrive();\n                    }\n                } else {\n                    setIsAuthenticated(false);\n                    setUser(null);\n                    setSession(null);\n                    console.log(\"No active Supabase session found\");\n                }\n            } catch (error) {\n                console.error(\"Error initializing auth:\", error);\n                setIsAuthenticated(false);\n                setUser(null);\n                setSession(null);\n            } finally{\n                setLoading(false);\n            }\n        };\n        initAuth();\n        // Set up Supabase auth state listener\n        const { data: authListener } = _lib_supabase__WEBPACK_IMPORTED_MODULE_4__.supabase.auth.onAuthStateChange(async (event, session)=>{\n            console.log(\"Auth state changed:\", event, session ? \"Session exists\" : \"No session\");\n            if (session) {\n                setSession(session);\n                setUser(session.user);\n                setIsAuthenticated(true);\n                if (event === \"SIGNED_IN\") {\n                    console.log(\"User signed in, updating state with session data\");\n                    // Initialize Google Drive when user signs in\n                    if (!isGoogleDriveInitialized) {\n                        initializeGoogleDrive();\n                    }\n                } else if (event === \"TOKEN_REFRESHED\") {\n                    console.log(\"Session token refreshed automatically\");\n                }\n            } else {\n                setSession(null);\n                setUser(null);\n                setIsAuthenticated(false);\n                setIsGoogleDriveAuthenticated(false);\n                if (event === \"SIGNED_OUT\") {\n                    console.log(\"User signed out, clearing session data\");\n                }\n            }\n        });\n        // Clean up the listener when the component unmounts\n        return ()=>{\n            authListener === null || authListener === void 0 ? void 0 : authListener.subscription.unsubscribe();\n        };\n    }, []);\n    // Initialize Google Drive API\n    const initializeGoogleDrive = async ()=>{\n        if (isGoogleDriveInitialized) return;\n        setIsGoogleDriveLoading(true);\n        try {\n            await _lib_googleDrive__WEBPACK_IMPORTED_MODULE_5__.googleDriveService.initialize();\n            setIsGoogleDriveInitialized(true);\n            // Check if already authenticated\n            const isAuthenticated = _lib_googleDrive__WEBPACK_IMPORTED_MODULE_5__.googleDriveService.isAuthenticated();\n            setIsGoogleDriveAuthenticated(isAuthenticated);\n            console.log(\"Google Drive API initialized, authenticated:\", isAuthenticated);\n        } catch (error) {\n            console.error(\"Failed to initialize Google Drive:\", error);\n        } finally{\n            setIsGoogleDriveLoading(false);\n        }\n    };\n    // Authenticate with Google Drive\n    const authenticateGoogleDrive = async ()=>{\n        setIsGoogleDriveLoading(true);\n        try {\n            // Make sure Google Drive is initialized\n            if (!isGoogleDriveInitialized) {\n                await initializeGoogleDrive();\n            }\n            // Authenticate with Google Drive\n            const authenticated = await _lib_googleDrive__WEBPACK_IMPORTED_MODULE_5__.googleDriveService.authenticate();\n            setIsGoogleDriveAuthenticated(authenticated);\n            console.log(\"Google Drive authentication result:\", authenticated);\n            return authenticated;\n        } catch (error) {\n            console.error(\"Google Drive authentication error:\", error);\n            return false;\n        } finally{\n            setIsGoogleDriveLoading(false);\n        }\n    };\n    const login = async (email, password)=>{\n        try {\n            const result = await _lib_api__WEBPACK_IMPORTED_MODULE_3__.authAPI.login({\n                email,\n                password\n            });\n            console.log(\"Login result in AuthContext:\", result && result.session ? \"Session present\" : \"No session\");\n            if (result && result.session) {\n                setSession(result.session);\n                setUser(result.user);\n                setIsAuthenticated(true);\n                // Initialize Google Drive after login\n                if (!isGoogleDriveInitialized) {\n                    initializeGoogleDrive();\n                }\n            } else {\n                console.warn(\"Login successful but no session returned:\", result);\n            }\n            return result;\n        } catch (error) {\n            console.error(\"Login error in context:\", error);\n            throw error;\n        }\n    };\n    const register = async (email, username, password)=>{\n        try {\n            const result = await _lib_api__WEBPACK_IMPORTED_MODULE_3__.authAPI.register({\n                email,\n                username,\n                password\n            });\n            return result;\n        } catch (error) {\n            console.error(\"Registration error in context:\", error);\n            throw error;\n        }\n    };\n    const logout = async ()=>{\n        try {\n            console.log(\"Logging out user...\");\n            await _lib_api__WEBPACK_IMPORTED_MODULE_3__.authAPI.logout();\n            // Clear authentication state\n            setIsAuthenticated(false);\n            setUser(null);\n            setSession(null);\n            setIsGoogleDriveAuthenticated(false);\n            console.log(\"Logout complete, redirecting to auth page\");\n            router.push(\"/auth\");\n        } catch (error) {\n            console.error(\"Logout error:\", error);\n        }\n    };\n    const checkAuth = async ()=>{\n        try {\n            // Get the current session from Supabase\n            const { data: { session } } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_4__.supabase.auth.getSession();\n            if (session) {\n                setSession(session);\n                setUser(session.user);\n                setIsAuthenticated(true);\n                return true;\n            } else {\n                setIsAuthenticated(false);\n                setUser(null);\n                setSession(null);\n                return false;\n            }\n        } catch (error) {\n            console.error(\"Check auth error:\", error);\n            return false;\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            isAuthenticated,\n            user,\n            session,\n            loading,\n            login,\n            register,\n            logout,\n            checkAuth,\n            // Google Drive authentication\n            isGoogleDriveAuthenticated,\n            isGoogleDriveLoading,\n            authenticateGoogleDrive,\n            initializeGoogleDrive\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/hudsonmitchell-pullman/nhsmun-2025-mvp/frontend/lib/context/AuthContext.tsx\",\n        lineNumber: 251,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(AuthProvider, \"OUFN0F3iWeiHg66BIr99i8Ls8xE=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9jb250ZXh0L0F1dGhDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUV5RjtBQUM3QztBQUNSO0FBQ007QUFFYTtBQW1CdkQsMENBQTBDO0FBQzFDLE1BQU1TLDRCQUFjUixvREFBYUEsQ0FBa0I7SUFDakRTLGlCQUFpQjtJQUNqQkMsTUFBTTtJQUNOQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsT0FBTyxVQUFZO0lBQ25CQyxVQUFVLFVBQVk7SUFDdEJDLFFBQVEsV0FBYTtJQUNyQkMsV0FBVyxVQUFZO0lBQ3ZCLHVDQUF1QztJQUN2Q0MsNEJBQTRCO0lBQzVCQyxzQkFBc0I7SUFDdEJDLHlCQUF5QixVQUFZO0lBQ3JDQyx1QkFBdUIsV0FBYTtBQUN0QztBQUVBLHNDQUFzQztBQUMvQixNQUFNQyxVQUFVOztJQUFNbkIsT0FBQUEsaURBQVVBLENBQUNNO0FBQVcsRUFBRTtHQUF4Q2E7QUFFTixNQUFNQyxlQUFlO1FBQUMsRUFBRUMsUUFBUSxFQUEyQjs7SUFDaEUsTUFBTSxDQUFDZCxpQkFBaUJlLG1CQUFtQixHQUFHdkIsK0NBQVFBLENBQUM7SUFDdkQsTUFBTSxDQUFDUyxNQUFNZSxRQUFRLEdBQUd4QiwrQ0FBUUEsQ0FBYztJQUM5QyxNQUFNLENBQUNVLFNBQVNlLFdBQVcsR0FBR3pCLCtDQUFRQSxDQUFpQjtJQUN2RCxNQUFNLENBQUNXLFNBQVNlLFdBQVcsR0FBRzFCLCtDQUFRQSxDQUFDO0lBQ3ZDLHFCQUFxQjtJQUNyQixNQUFNLENBQUNnQiw0QkFBNEJXLDhCQUE4QixHQUFHM0IsK0NBQVFBLENBQUM7SUFDN0UsTUFBTSxDQUFDaUIsc0JBQXNCVyx3QkFBd0IsR0FBRzVCLCtDQUFRQSxDQUFDO0lBQ2pFLE1BQU0sQ0FBQzZCLDBCQUEwQkMsNEJBQTRCLEdBQUc5QiwrQ0FBUUEsQ0FBQztJQUV6RSxNQUFNK0IsU0FBUzVCLDBEQUFTQTtJQUV4QixrQ0FBa0M7SUFDbENELGdEQUFTQSxD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QixNQUFNLEVBQUV2QixPQUFPLEVBQUUsRUFBRSxHQUFHLE1BQU1MLG1EQUFRQSxDQUFDNkIsSUFBSSxDQUFDQyxVQUFVO1lBRTVELElBQUl6QixTQUFTO2dCQUNYZSxXQUFXZjtnQkFDWGMsUUFBUWQsUUFBUUQsSUFBSTtnQkFDcEJjLG1CQUFtQjtnQkFDbkIsT0FBTztZQUNULE9BQU87Z0JBQ0xBLG1CQUFtQjtnQkFDbkJDLFFBQVE7Z0JBQ1JDLFdBQVc7Z0JBQ1gsT0FBTztZQUNUO1FBQ0YsRUFBRSxPQUFPYSxPQUFPO1lBQ2RGLFFBQVFFLEtBQUssQ0FBQyxxQkFBcUJBO1lBQ25DLE9BQU87UUFDVDtJQUNGO0lBRUEscUJBQ0UsOERBQUMvQixZQUFZOEMsUUFBUTtRQUNuQkMsT0FBTztZQUNMOUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQSw4QkFBOEI7WUFDOUJDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1FBQ0Y7a0JBRUNHOzs7Ozs7QUFHUCxFQUFFO0lBaE9XRDs7UUFVSWxCLHNEQUFTQTs7O0tBVmJrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvY29udGV4dC9BdXRoQ29udGV4dC50c3g/ZWZmYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VTdGF0ZSwgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L25hdmlnYXRpb24nO1xuaW1wb3J0IHsgYXV0aEFQSSB9IGZyb20gJ0AvbGliL2FwaSc7XG5pbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJztcbmltcG9ydCB7IFNlc3Npb24sIFVzZXIgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuaW1wb3J0IHsgZ29vZ2xlRHJpdmVTZXJ2aWNlIH0gZnJvbSAnQC9saWIvZ29vZ2xlRHJpdmUnO1xuXG4vLyBEZWZpbmUgdGhlIHR5cGUgZm9yIHRoZSBjb250ZXh0IHZhbHVlXG5pbnRlcmZhY2UgQXV0aENvbnRleHRUeXBlIHtcbiAgaXNBdXRoZW50aWNhdGVkOiBib29sZWFuO1xuICB1c2VyOiBVc2VyIHwgbnVsbDtcbiAgc2Vzc2lvbjogU2Vzc2lvbiB8IG51bGw7XG4gIGxvYWRpbmc6IGJvb2xlYW47XG4gIGxvZ2luOiAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTxhbnk+O1xuICByZWdpc3RlcjogKGVtYWlsOiBzdHJpbmcsIHVzZXJuYW1lOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IFByb21pc2U8YW55PjtcbiAgbG9nb3V0OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBjaGVja0F1dGg6ICgpID0+IFByb21pc2U8Ym9vbGVhbj47XG4gIC8vIEdvb2dsZSBEcml2ZSBhdXRoZW50aWNhdGlvblxuICBpc0dvb2dsZURyaXZlQXV0aGVudGljYXRlZDogYm9vbGVhbjtcbiAgaXNHb29nbGVEcml2ZUxvYWRpbmc6IGJvb2xlYW47XG4gIGF1dGhlbnRpY2F0ZUdvb2dsZURyaXZlOiAoKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuICBpbml0aWFsaXplR29vZ2xlRHJpdmU6ICgpID0+IFByb21pc2U8dm9pZD47XG59XG5cbi8vIENyZWF0ZSB0aGUgY29udGV4dCB3aXRoIGEgZGVmYXVsdCB2YWx1ZVxuY29uc3QgQXV0aENvbnRleHQgPSBjcmVhdGVDb250ZXh0PEF1dGhDb250ZXh0VHlwZT4oe1xuICBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICB1c2VyOiBudWxsLFxuICBzZXNzaW9uOiBudWxsLFxuICBsb2FkaW5nOiB0cnVlLFxuICBsb2dpbjogYXN5bmMgKCkgPT4gbnVsbCxcbiAgcmVnaXN0ZXI6IGFzeW5jICgpID0+IG51bGwsXG4gIGxvZ291dDogYXN5bmMgKCkgPT4ge30sXG4gIGNoZWNrQXV0aDogYXN5bmMgKCkgPT4gZmFsc2UsXG4gIC8vIEdvb2dsZSBEcml2ZSBhdXRoZW50aWNhdGlvbiBkZWZhdWx0c1xuICBpc0dvb2dsZURyaXZlQXV0aGVudGljYXRlZDogZmFsc2UsXG4gIGlzR29vZ2xlRHJpdmVMb2FkaW5nOiBmYWxzZSxcbiAgYXV0aGVudGljYXRlR29vZ2xlRHJpdmU6IGFzeW5jICgpID0+IGZhbHNlLFxuICBpbml0aWFsaXplR29vZ2xlRHJpdmU6IGFzeW5jICgpID0+IHt9LFxufSk7XG5cbi8vIEN1c3RvbSBob29rIHRvIHVzZSB0aGUgYXV0aCBjb250ZXh0XG5leHBvcnQgY29uc3QgdXNlQXV0aCA9ICgpID0+IHVzZUNvbnRleHQoQXV0aENvbnRleHQpO1xuXG5leHBvcnQgY29uc3QgQXV0aFByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3ROb2RlIH0pID0+IHtcbiAgY29uc3QgW2lzQXV0aGVudGljYXRlZCwgc2V0SXNBdXRoZW50aWNhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3VzZXIsIHNldFVzZXJdID0gdXNlU3RhdGU8VXNlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbc2Vzc2lvbiwgc2V0U2Vzc2lvbl0gPSB1c2VTdGF0ZTxTZXNzaW9uIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICAvLyBHb29nbGUgRHJpdmUgc3RhdGVcbiAgY29uc3QgW2lzR29vZ2xlRHJpdmVBdXRoZW50aWNhdGVkLCBzZXRJc0dvb2dsZURyaXZlQXV0aGVudGljYXRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0dvb2dsZURyaXZlTG9hZGluZywgc2V0SXNHb29nbGVEcml2ZUxvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNHb29nbGVEcml2ZUluaXRpYWxpemVkLCBzZXRJc0dvb2dsZURyaXZlSW5pdGlhbGl6ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBhdXRoZW50aWNhdGlvbiBzdGF0ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGluaXRBdXRoID0gYXN5bmMgKCkgPT4ge1xuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBzZXNzaW9uIGZyb20gU3VwYWJhc2VcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICAgIHNldFNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgc2V0VXNlcihzZXNzaW9uLnVzZXIpO1xuICAgICAgICAgIHNldElzQXV0aGVudGljYXRlZCh0cnVlKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQXV0aCBpbml0aWFsaXplZCBmcm9tIFN1cGFiYXNlIHNlc3Npb24nKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBJbml0aWFsaXplIEdvb2dsZSBEcml2ZSB3aGVuIHVzZXIgaXMgYXV0aGVudGljYXRlZFxuICAgICAgICAgIGlmICghaXNHb29nbGVEcml2ZUluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBpbml0aWFsaXplR29vZ2xlRHJpdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKGZhbHNlKTtcbiAgICAgICAgICBzZXRVc2VyKG51bGwpO1xuICAgICAgICAgIHNldFNlc3Npb24obnVsbCk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ05vIGFjdGl2ZSBTdXBhYmFzZSBzZXNzaW9uIGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBhdXRoOicsIGVycm9yKTtcbiAgICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKGZhbHNlKTtcbiAgICAgICAgc2V0VXNlcihudWxsKTtcbiAgICAgICAgc2V0U2Vzc2lvbihudWxsKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpbml0QXV0aCgpO1xuXG4gICAgLy8gU2V0IHVwIFN1cGFiYXNlIGF1dGggc3RhdGUgbGlzdGVuZXJcbiAgICBjb25zdCB7IGRhdGE6IGF1dGhMaXN0ZW5lciB9ID0gc3VwYWJhc2UuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZShhc3luYyAoZXZlbnQsIHNlc3Npb24pID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdBdXRoIHN0YXRlIGNoYW5nZWQ6JywgZXZlbnQsIHNlc3Npb24gPyAnU2Vzc2lvbiBleGlzdHMnIDogJ05vIHNlc3Npb24nKTtcbiAgICAgIFxuICAgICAgaWYgKHNlc3Npb24pIHtcbiAgICAgICAgc2V0U2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgc2V0VXNlcihzZXNzaW9uLnVzZXIpO1xuICAgICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQodHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZXZlbnQgPT09ICdTSUdORURfSU4nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgc2lnbmVkIGluLCB1cGRhdGluZyBzdGF0ZSB3aXRoIHNlc3Npb24gZGF0YScpO1xuICAgICAgICAgIC8vIEluaXRpYWxpemUgR29vZ2xlIERyaXZlIHdoZW4gdXNlciBzaWducyBpblxuICAgICAgICAgIGlmICghaXNHb29nbGVEcml2ZUluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBpbml0aWFsaXplR29vZ2xlRHJpdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09ICdUT0tFTl9SRUZSRVNIRUQnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1Nlc3Npb24gdG9rZW4gcmVmcmVzaGVkIGF1dG9tYXRpY2FsbHknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2Vzc2lvbihudWxsKTtcbiAgICAgICAgc2V0VXNlcihudWxsKTtcbiAgICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKGZhbHNlKTtcbiAgICAgICAgc2V0SXNHb29nbGVEcml2ZUF1dGhlbnRpY2F0ZWQoZmFsc2UpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGV2ZW50ID09PSAnU0lHTkVEX09VVCcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNlciBzaWduZWQgb3V0LCBjbGVhcmluZyBzZXNzaW9uIGRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xlYW4gdXAgdGhlIGxpc3RlbmVyIHdoZW4gdGhlIGNvbXBvbmVudCB1bm1vdW50c1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBhdXRoTGlzdGVuZXI/LnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICAvLyBJbml0aWFsaXplIEdvb2dsZSBEcml2ZSBBUElcbiAgY29uc3QgaW5pdGlhbGl6ZUdvb2dsZURyaXZlID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0dvb2dsZURyaXZlSW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICBcbiAgICBzZXRJc0dvb2dsZURyaXZlTG9hZGluZyh0cnVlKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZ29vZ2xlRHJpdmVTZXJ2aWNlLmluaXRpYWxpemUoKTtcbiAgICAgIHNldElzR29vZ2xlRHJpdmVJbml0aWFsaXplZCh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBhdXRoZW50aWNhdGVkXG4gICAgICBjb25zdCBpc0F1dGhlbnRpY2F0ZWQgPSBnb29nbGVEcml2ZVNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKCk7XG4gICAgICBzZXRJc0dvb2dsZURyaXZlQXV0aGVudGljYXRlZChpc0F1dGhlbnRpY2F0ZWQpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnR29vZ2xlIERyaXZlIEFQSSBpbml0aWFsaXplZCwgYXV0aGVudGljYXRlZDonLCBpc0F1dGhlbnRpY2F0ZWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBHb29nbGUgRHJpdmU6JywgZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0dvb2dsZURyaXZlTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEF1dGhlbnRpY2F0ZSB3aXRoIEdvb2dsZSBEcml2ZVxuICBjb25zdCBhdXRoZW50aWNhdGVHb29nbGVEcml2ZSA9IGFzeW5jICgpID0+IHtcbiAgICBzZXRJc0dvb2dsZURyaXZlTG9hZGluZyh0cnVlKTtcbiAgICB0cnkge1xuICAgICAgLy8gTWFrZSBzdXJlIEdvb2dsZSBEcml2ZSBpcyBpbml0aWFsaXplZFxuICAgICAgaWYgKCFpc0dvb2dsZURyaXZlSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgYXdhaXQgaW5pdGlhbGl6ZUdvb2dsZURyaXZlKCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEF1dGhlbnRpY2F0ZSB3aXRoIEdvb2dsZSBEcml2ZVxuICAgICAgY29uc3QgYXV0aGVudGljYXRlZCA9IGF3YWl0IGdvb2dsZURyaXZlU2VydmljZS5hdXRoZW50aWNhdGUoKTtcbiAgICAgIHNldElzR29vZ2xlRHJpdmVBdXRoZW50aWNhdGVkKGF1dGhlbnRpY2F0ZWQpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnR29vZ2xlIERyaXZlIGF1dGhlbnRpY2F0aW9uIHJlc3VsdDonLCBhdXRoZW50aWNhdGVkKTtcbiAgICAgIHJldHVybiBhdXRoZW50aWNhdGVkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdHb29nbGUgRHJpdmUgYXV0aGVudGljYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0dvb2dsZURyaXZlTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGxvZ2luID0gYXN5bmMgKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aEFQSS5sb2dpbih7IGVtYWlsLCBwYXNzd29yZCB9KTtcbiAgICAgIGNvbnNvbGUubG9nKCdMb2dpbiByZXN1bHQgaW4gQXV0aENvbnRleHQ6JywgcmVzdWx0ICYmIHJlc3VsdC5zZXNzaW9uID8gJ1Nlc3Npb24gcHJlc2VudCcgOiAnTm8gc2Vzc2lvbicpO1xuICAgICAgXG4gICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5zZXNzaW9uKSB7XG4gICAgICAgIHNldFNlc3Npb24ocmVzdWx0LnNlc3Npb24pO1xuICAgICAgICBzZXRVc2VyKHJlc3VsdC51c2VyKTtcbiAgICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKHRydWUpO1xuICAgICAgICBcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBHb29nbGUgRHJpdmUgYWZ0ZXIgbG9naW5cbiAgICAgICAgaWYgKCFpc0dvb2dsZURyaXZlSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICBpbml0aWFsaXplR29vZ2xlRHJpdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdMb2dpbiBzdWNjZXNzZnVsIGJ1dCBubyBzZXNzaW9uIHJldHVybmVkOicsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvZ2luIGVycm9yIGluIGNvbnRleHQ6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlZ2lzdGVyID0gYXN5bmMgKGVtYWlsOiBzdHJpbmcsIHVzZXJuYW1lOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYXV0aEFQSS5yZWdpc3Rlcih7IGVtYWlsLCB1c2VybmFtZSwgcGFzc3dvcmQgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdSZWdpc3RyYXRpb24gZXJyb3IgaW4gY29udGV4dDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgbG9nb3V0ID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnTG9nZ2luZyBvdXQgdXNlci4uLicpO1xuICAgICAgYXdhaXQgYXV0aEFQSS5sb2dvdXQoKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgYXV0aGVudGljYXRpb24gc3RhdGVcbiAgICAgIHNldElzQXV0aGVudGljYXRlZChmYWxzZSk7XG4gICAgICBzZXRVc2VyKG51bGwpO1xuICAgICAgc2V0U2Vzc2lvbihudWxsKTtcbiAgICAgIHNldElzR29vZ2xlRHJpdmVBdXRoZW50aWNhdGVkKGZhbHNlKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0xvZ291dCBjb21wbGV0ZSwgcmVkaXJlY3RpbmcgdG8gYXV0aCBwYWdlJyk7XG4gICAgICByb3V0ZXIucHVzaCgnL2F1dGgnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignTG9nb3V0IGVycm9yOicsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY2hlY2tBdXRoID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgc2Vzc2lvbiBmcm9tIFN1cGFiYXNlXG4gICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFNlc3Npb24oKTtcbiAgICAgIFxuICAgICAgaWYgKHNlc3Npb24pIHtcbiAgICAgICAgc2V0U2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgc2V0VXNlcihzZXNzaW9uLnVzZXIpO1xuICAgICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQodHJ1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKGZhbHNlKTtcbiAgICAgICAgc2V0VXNlcihudWxsKTtcbiAgICAgICAgc2V0U2Vzc2lvbihudWxsKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDaGVjayBhdXRoIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8QXV0aENvbnRleHQuUHJvdmlkZXIgXG4gICAgICB2YWx1ZT17eyBcbiAgICAgICAgaXNBdXRoZW50aWNhdGVkLCBcbiAgICAgICAgdXNlciwgXG4gICAgICAgIHNlc3Npb24sXG4gICAgICAgIGxvYWRpbmcsXG4gICAgICAgIGxvZ2luLCBcbiAgICAgICAgcmVnaXN0ZXIsXG4gICAgICAgIGxvZ291dCxcbiAgICAgICAgY2hlY2tBdXRoLFxuICAgICAgICAvLyBHb29nbGUgRHJpdmUgYXV0aGVudGljYXRpb25cbiAgICAgICAgaXNHb29nbGVEcml2ZUF1dGhlbnRpY2F0ZWQsXG4gICAgICAgIGlzR29vZ2xlRHJpdmVMb2FkaW5nLFxuICAgICAgICBhdXRoZW50aWNhdGVHb29nbGVEcml2ZSxcbiAgICAgICAgaW5pdGlhbGl6ZUdvb2dsZURyaXZlXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0F1dGhDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTsgIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZVJvdXRlciIsImF1dGhBUEkiLCJzdXBhYmFzZSIsImdvb2dsZURyaXZlU2VydmljZSIsIkF1dGhDb250ZXh0IiwiaXNBdXRoZW50aWNhdGVkIiwidXNlciIsInNlc3Npb24iLCJsb2FkaW5nIiwibG9naW4iLCJyZWdpc3RlciIsImxvZ291dCIsImNoZWNrQXV0aCIsImlzR29vZ2xlRHJpdmVBdXRoZW50aWNhdGVkIiwiaXNHb29nbGVEcml2ZUxvYWRpbmciLCJhdXRoZW50aWNhdGVHb29nbGVEcml2ZSIsImluaXRpYWxpemVHb29nbGVEcml2ZSIsInVzZUF1dGgiLCJBdXRoUHJvdmlkZXIiLCJjaGlsZHJlbiIsInNldElzQXV0aGVudGljYXRlZCIsInNldFVzZXIiLCJzZXRTZXNzaW9uIiwic2V0TG9hZGluZyIsInNldElzR29vZ2xlRHJpdmVBdXRoZW50aWNhdGVkIiwic2V0SXNHb29nbGVEcml2ZUxvYWRpbmciLCJpc0dvb2dsZURyaXZlSW5pdGlhbGl6ZWQiLCJzZXRJc0dvb2dsZURyaXZlSW5pdGlhbGl6ZWQiLCJyb3V0ZXIiLCJpbml0QXV0aCIsImRhdGEiLCJhdXRoIiwiZ2V0U2Vzc2lvbiIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsImF1dGhMaXN0ZW5lciIsIm9uQXV0aFN0YXRlQ2hhbmdlIiwiZXZlbnQiLCJzdWJzY3JpcHRpb24iLCJ1bnN1YnNjcmliZSIsImluaXRpYWxpemUiLCJhdXRoZW50aWNhdGVkIiwiYXV0aGVudGljYXRlIiwiZW1haWwiLCJwYXNzd29yZCIsInJlc3VsdCIsIndhcm4iLCJ1c2VybmFtZSIsInB1c2giLCJQcm92aWRlciIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/context/AuthContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/googleDrive.ts":
/*!****************************!*\
  !*** ./lib/googleDrive.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConflictDetectionService: function() { return /* binding */ ConflictDetectionService; },\n/* harmony export */   GoogleDriveService: function() { return /* binding */ GoogleDriveService; },\n/* harmony export */   conflictDetectionService: function() { return /* binding */ conflictDetectionService; },\n/* harmony export */   googleDriveService: function() { return /* binding */ googleDriveService; }\n/* harmony export */ });\n/**\n * Google Drive API Integration Service\n * \n * This service handles the integration with Google Drive API for document management\n * and real-time collaboration.\n * \n * Google Cloud Project Setup Instructions:\n * 1. Create a new project in Google Cloud Console (https://console.cloud.google.com/)\n * 2. Enable the Google Drive API\n * 3. Configure OAuth consent screen\n *    - User Type: External\n *    - Application name: MUN Connect\n *    - Authorized domains: your-domain.com\n *    - Developer contact information: your-email@example.com\n * 4. Create OAuth 2.0 credentials\n *    - Application type: Web application\n *    - Name: MUN Connect Web Client\n *    - Authorized JavaScript origins: http://localhost:3000, https://your-domain.com\n *    - Authorized redirect URIs: http://localhost:3000/api/auth/callback/google, https://your-domain.com/api/auth/callback/google\n * 5. Add the following environment variables to your .env.local file:\n *    - GOOGLE_CLIENT_ID=your-client-id\n *    - GOOGLE_CLIENT_SECRET=your-client-secret\n *    - GOOGLE_API_KEY=your-api-key (for public API access)\n */ // Default configuration - these values should be replaced with environment variables\nconst DEFAULT_CONFIG = {\n    clientId: \"913358736520-5biusol4f5ead6t86d7rv94rd0ar3gkn.apps.googleusercontent.com\" || 0,\n    apiKey: \"AIzaSyB-pZ0FV758VUs_pIZ0Ck2iq5Wx0FDJCxw\" || 0,\n    scopes: [\n        \"https://www.googleapis.com/auth/drive.file\",\n        \"https://www.googleapis.com/auth/drive.appdata\"\n    ]\n};\n// Google Drive API Service\nclass GoogleDriveService {\n    /**\n   * Initialize the Google Drive API\n   * This loads the required libraries and initializes the API client\n   */ async initialize() {\n        return new Promise((resolve, reject)=>{\n            try {\n                // Load the Google API client library\n                const script1 = document.createElement(\"script\");\n                script1.src = \"https://apis.google.com/js/api.js\";\n                script1.onload = ()=>{\n                    this.gapiLoaded = true;\n                    this.loadGapiClient().then(()=>{\n                        if (this.gisLoaded) resolve();\n                    });\n                };\n                script1.onerror = (error)=>reject(\"Failed to load Google API client: \".concat(error));\n                document.body.appendChild(script1);\n                // Load the Google Identity Services library\n                const script2 = document.createElement(\"script\");\n                script2.src = \"https://accounts.google.com/gsi/client\";\n                script2.onload = ()=>{\n                    this.gisLoaded = true;\n                    this.initializeTokenClient();\n                    if (this.gapiLoaded) resolve();\n                };\n                script2.onerror = (error)=>reject(\"Failed to load Google Identity Services: \".concat(error));\n                document.body.appendChild(script2);\n            } catch (error) {\n                reject(\"Error initializing Google Drive API: \".concat(error));\n            }\n        });\n    }\n    /**\n   * Load the Google API client library\n   */ async loadGapiClient() {\n        return new Promise((resolve, reject)=>{\n            try {\n                window.gapi.load(\"client\", {\n                    callback: async ()=>{\n                        try {\n                            await window.gapi.client.init({\n                                apiKey: this.config.apiKey,\n                                discoveryDocs: [\n                                    \"https://www.googleapis.com/discovery/v1/apis/drive/v3/rest\"\n                                ]\n                            });\n                            resolve();\n                        } catch (error) {\n                            reject(\"Error initializing GAPI client: \".concat(error));\n                        }\n                    },\n                    onerror: (error)=>reject(\"Error loading GAPI client: \".concat(error))\n                });\n            } catch (error) {\n                reject(\"Failed to load GAPI client: \".concat(error));\n            }\n        });\n    }\n    /**\n   * Initialize the Google Identity Services token client\n   */ initializeTokenClient() {\n        this.tokenClient = window.google.accounts.oauth2.initTokenClient({\n            client_id: this.config.clientId,\n            scope: this.config.scopes.join(\" \"),\n            callback: (tokenResponse)=>{\n                if (tokenResponse.error) {\n                    console.error(\"Error getting access token: \".concat(tokenResponse.error));\n                    return;\n                }\n                this.accessToken = tokenResponse.access_token;\n                window.gapi.client.setToken(tokenResponse);\n            }\n        });\n    }\n    /**\n   * Authenticate the user and request access to Google Drive\n   */ async authenticate() {\n        return new Promise((resolve)=>{\n            if (!this.tokenClient) {\n                console.error(\"Token client not initialized\");\n                resolve(false);\n                return;\n            }\n            try {\n                this.tokenClient.callback = (resp)=>{\n                    if (resp.error) {\n                        console.error(\"Error during authentication: \".concat(resp.error));\n                        resolve(false);\n                        return;\n                    }\n                    this.accessToken = resp.access_token;\n                    resolve(true);\n                };\n                if (window.gapi.client.getToken() === null) {\n                    // Request an access token\n                    this.tokenClient.requestAccessToken({\n                        prompt: \"consent\"\n                    });\n                } else {\n                    // Already have an access token\n                    this.accessToken = window.gapi.client.getToken().access_token;\n                    resolve(true);\n                }\n            } catch (error) {\n                console.error(\"Error authenticating: \".concat(error));\n                resolve(false);\n            }\n        });\n    }\n    /**\n   * Check if the user is authenticated\n   */ isAuthenticated() {\n        return this.accessToken !== null;\n    }\n    /**\n   * Create a new Google Doc for a document\n   * @param document The document to create a Google Doc for\n   * @returns The ID of the created Google Doc\n   */ async createGoogleDoc(document1) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            const response = await window.gapi.client.drive.files.create({\n                resource: {\n                    name: document1.title,\n                    mimeType: \"application/vnd.google-apps.document\",\n                    description: \"MUN Connect document: \".concat(document1.type, \" for \").concat(document1.committee, \" - \").concat(document1.country),\n                    properties: {\n                        munConnectDocId: document1.id,\n                        documentType: document1.type,\n                        committee: document1.committee,\n                        country: document1.country\n                    }\n                },\n                fields: \"id,webViewLink\"\n            });\n            return response.result.id;\n        } catch (error) {\n            console.error(\"Error creating Google Doc: \".concat(error));\n            throw new Error(\"Failed to create Google Doc: \".concat(error));\n        }\n    }\n    /**\n   * Get a Google Doc by its ID\n   * @param googleDocId The ID of the Google Doc to get\n   * @returns The Google Doc metadata\n   */ async getGoogleDoc(googleDocId) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            const response = await window.gapi.client.drive.files.get({\n                fileId: googleDocId,\n                fields: \"id,name,webViewLink,modifiedTime,capabilities\"\n            });\n            return response.result;\n        } catch (error) {\n            console.error(\"Error getting Google Doc: \".concat(error));\n            throw new Error(\"Failed to get Google Doc: \".concat(error));\n        }\n    }\n    /**\n   * Update a Google Doc's content\n   * @param googleDocId The ID of the Google Doc to update\n   * @param content The new content of the Google Doc\n   */ async updateGoogleDoc(googleDocId, content) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            // This is a simplified version. In a real implementation,\n            // you would use the Google Docs API to update the document content.\n            // For simplicity, we're just updating the document's metadata here.\n            await window.gapi.client.drive.files.update({\n                fileId: googleDocId,\n                resource: {\n                    properties: {\n                        lastUpdated: new Date().toISOString()\n                    }\n                }\n            });\n        } catch (error) {\n            console.error(\"Error updating Google Doc: \".concat(error));\n            throw new Error(\"Failed to update Google Doc: \".concat(error));\n        }\n    }\n    /**\n   * Export a Google Doc to a specific format (PDF, DOCX)\n   * @param googleDocId The ID of the Google Doc to export\n   * @param mimeType The mime type to export to (e.g., 'application/pdf')\n   * @returns A URL to download the exported file\n   */ async exportGoogleDoc(googleDocId, mimeType) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            const response = await fetch(\"https://www.googleapis.com/drive/v3/files/\".concat(googleDocId, \"/export?mimeType=\").concat(encodeURIComponent(mimeType)), {\n                headers: {\n                    Authorization: \"Bearer \".concat(this.accessToken)\n                }\n            });\n            if (!response.ok) {\n                throw new Error(\"Failed to export Google Doc: \".concat(response.statusText));\n            }\n            const blob = await response.blob();\n            return URL.createObjectURL(blob);\n        } catch (error) {\n            console.error(\"Error exporting Google Doc: \".concat(error));\n            throw new Error(\"Failed to export Google Doc: \".concat(error));\n        }\n    }\n    /**\n   * Watch for changes to a Google Doc\n   * This is a placeholder for real-time sync functionality.\n   * In a production environment, you would use the Google Drive API's\n   * watch method or establish a WebSocket connection.\n   * \n   * @param googleDocId The ID of the Google Doc to watch\n   * @param callback The callback to call when the Google Doc changes\n   * @returns A function to stop watching for changes\n   */ watchGoogleDoc(googleDocId, callback) {\n        // This is a placeholder. In a real implementation, you would use the Google Drive API's\n        // changes.watch method or establish a WebSocket connection.\n        const checkInterval = 5000; // Check every 5 seconds\n        let lastModified = null;\n        const intervalId = setInterval(async ()=>{\n            try {\n                if (!this.isAuthenticated()) {\n                    console.warn(\"Not authenticated with Google Drive\");\n                    return;\n                }\n                const doc = await this.getGoogleDoc(googleDocId);\n                if (lastModified !== null && doc.modifiedTime !== lastModified) {\n                    // Document has changed\n                    callback({\n                        documentId: googleDocId,\n                        modifiedTime: doc.modifiedTime\n                    });\n                }\n                lastModified = doc.modifiedTime;\n            } catch (error) {\n                console.error(\"Error checking for Google Doc changes: \".concat(error));\n            }\n        }, checkInterval);\n        // Return a function to stop watching for changes\n        return ()=>clearInterval(intervalId);\n    }\n    /**\n   * Import a file from Google Drive\n   * @param fileId The ID of the file to import\n   * @returns The imported file data\n   */ async importFile(fileId) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            // Get file metadata\n            const metadataResponse = await window.gapi.client.drive.files.get({\n                fileId,\n                fields: \"name,mimeType\"\n            });\n            const { name, mimeType } = metadataResponse.result;\n            // Get file content\n            const contentResponse = await fetch(\"https://www.googleapis.com/drive/v3/files/\".concat(fileId, \"?alt=media\"), {\n                headers: {\n                    Authorization: \"Bearer \".concat(this.accessToken)\n                }\n            });\n            if (!contentResponse.ok) {\n                throw new Error(\"Failed to get file content: \".concat(contentResponse.statusText));\n            }\n            let content = \"\";\n            if (mimeType === \"application/vnd.google-apps.document\") {\n                // Export Google Doc to text\n                const exportUrl = await this.exportGoogleDoc(fileId, \"text/plain\");\n                const exportResponse = await fetch(exportUrl);\n                content = await exportResponse.text();\n            } else {\n                // Get raw content for other file types\n                content = await contentResponse.text();\n            }\n            return {\n                name,\n                content,\n                mimeType\n            };\n        } catch (error) {\n            console.error(\"Error importing file: \".concat(error));\n            throw new Error(\"Failed to import file: \".concat(error));\n        }\n    }\n    /**\n   * List files from Google Drive\n   * @param query Optional search query to filter files\n   * @returns Array of Google Drive files\n   */ async listDriveFiles() {\n        let query = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            // Use the Google Drive API to list files\n            const response = await window.gapi.client.drive.files.list({\n                pageSize: 50,\n                fields: \"files(id, name, mimeType, modifiedTime, webViewLink)\",\n                q: query ? query : \"trashed = false\",\n                orderBy: \"modifiedTime desc\"\n            });\n            console.log(\"Google Drive files:\", response.result.files);\n            return response.result.files || [];\n        } catch (error) {\n            console.error(\"Error listing Drive files:\", error);\n            throw error;\n        }\n    }\n    constructor(config = {}){\n        this.gapiLoaded = false;\n        this.gisLoaded = false;\n        this.tokenClient = null;\n        this.accessToken = null;\n        this.config = {\n            ...DEFAULT_CONFIG,\n            ...config\n        };\n    }\n}\n/**\n * AI Conflict Detection Service\n * \n * This service implements a basic AI conflict detection algorithm\n * to flag conflicts between documents or content sections.\n * \n * In a production environment, this would integrate with an\n * actual NLP or AI service.\n */ class ConflictDetectionService {\n    /**\n   * Detect conflicts between document content sections\n   * @param contentA First content section\n   * @param contentB Second content section\n   * @returns Array of detected conflicts\n   */ detectConflicts(contentA, contentB) {\n        const conflicts = [];\n        // This is a very basic implementation for demonstration purposes\n        // Check for duplicate content (exact matches)\n        const paragraphsA = contentA.split(\"\\n\\n\");\n        const paragraphsB = contentB.split(\"\\n\\n\");\n        // Compare paragraphs for exact matches (simulating duplicate content detection)\n        for (const paraA of paragraphsA){\n            if (paraA.length > 50 && paragraphsB.includes(paraA)) {\n                conflicts.push({\n                    type: \"duplicate_content\",\n                    description: \"Duplicate paragraph detected\",\n                    sections: [\n                        paraA\n                    ]\n                });\n            }\n        }\n        // Simulating conflicting perspective detection\n        // In a real implementation, this would use NLP to detect contradictory statements\n        const keywordsA = this.extractKeywords(contentA);\n        const keywordsB = this.extractKeywords(contentB);\n        // Check for opposite sentiment keywords (very simplified approach)\n        const oppositeKeywords = [\n            [\n                \"support\",\n                \"oppose\"\n            ],\n            [\n                \"agree\",\n                \"disagree\"\n            ],\n            [\n                \"approve\",\n                \"disapprove\"\n            ],\n            [\n                \"increase\",\n                \"decrease\"\n            ],\n            [\n                \"positive\",\n                \"negative\"\n            ]\n        ];\n        for (const [positive, negative] of oppositeKeywords){\n            if (keywordsA.includes(positive) && keywordsB.includes(negative) || keywordsA.includes(negative) && keywordsB.includes(positive)) {\n                conflicts.push({\n                    type: \"conflicting_perspective\",\n                    description: 'Potentially conflicting positions: \"'.concat(positive, '\" vs \"').concat(negative, '\"'),\n                    sections: this.findSentencesWithKeywords([\n                        contentA,\n                        contentB\n                    ], [\n                        positive,\n                        negative\n                    ])\n                });\n            }\n        }\n        return conflicts;\n    }\n    /**\n   * Extract keywords from text (simplified implementation)\n   * @param text The text to extract keywords from\n   * @returns Array of extracted keywords\n   */ extractKeywords(text) {\n        // This is a simplified implementation.\n        // In a real app, you would use a proper NLP library for keyword extraction.\n        const words = text.toLowerCase().split(/\\W+/);\n        return Array.from(new Set(words.filter((word)=>word.length > 3)));\n    }\n    /**\n   * Find sentences containing specific keywords\n   * @param texts Array of text blocks to search in\n   * @param keywords Keywords to search for\n   * @returns Array of sentences containing the keywords\n   */ findSentencesWithKeywords(texts, keywords) {\n        const sentences = [];\n        // Split texts into sentences and find those containing keywords\n        for (const text of texts){\n            const textSentences = text.split(/[.!?]+/).filter((s)=>s.trim().length > 0);\n            for (const sentence of textSentences){\n                for (const keyword of keywords){\n                    if (sentence.toLowerCase().includes(keyword.toLowerCase())) {\n                        sentences.push(sentence.trim());\n                        break;\n                    }\n                }\n            }\n        }\n        return sentences;\n    }\n}\n// Create singleton instances for use throughout the application\nconst googleDriveService = new GoogleDriveService();\nconst conflictDetectionService = new ConflictDetectionService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNLEdBQUc7WUFFekUsS0FBSyxNQUFNd0IsWUFBWUgsY0FBZTtnQkFDcEMsS0FBSyxNQUFNSSxXQUFXTixTQUFVO29CQUM5QixJQUFJSyxTQUFTWixXQUFXLEdBQUdYLFFBQVEsQ0FBQ3dCLFFBQVFiLFdBQVcsS0FBSzt3QkFDMURRLFVBQVVsQixJQUFJLENBQUNzQixTQUFTRCxJQUFJO3dCQUM1QjtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxPQUFPSDtJQUNUO0FBQ0Y7QUFFQSxnRUFBZ0U7QUFDekQsTUFBTU0scUJBQXFCLElBQUlsSixxQkFBcUI7QUFDcEQsTUFBTW1KLDJCQUEyQixJQUFJcEMsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9nb29nbGVEcml2ZS50cz81NzVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR29vZ2xlIERyaXZlIEFQSSBJbnRlZ3JhdGlvbiBTZXJ2aWNlXG4gKiBcbiAqIFRoaXMgc2VydmljZSBoYW5kbGVzIHRoZSBpbnRlZ3JhdGlvbiB3aXRoIEdvb2dsZSBEcml2ZSBBUEkgZm9yIGRvY3VtZW50IG1hbmFnZW1lbnRcbiAqIGFuZCByZWFsLXRpbWUgY29sbGFib3JhdGlvbi5cbiAqIFxuICogR29vZ2xlIENsb3VkIFByb2plY3QgU2V0dXAgSW5zdHJ1Y3Rpb25zOlxuICogMS4gQ3JlYXRlIGEgbmV3IHByb2plY3QgaW4gR29vZ2xlIENsb3VkIENvbnNvbGUgKGh0dHBzOi8vY29uc29sZS5jbG91ZC5nb29nbGUuY29tLylcbiAqIDIuIEVuYWJsZSB0aGUgR29vZ2xlIERyaXZlIEFQSVxuICogMy4gQ29uZmlndXJlIE9BdXRoIGNvbnNlbnQgc2NyZWVuXG4gKiAgICAtIFVzZXIgVHlwZTogRXh0ZXJuYWxcbiAqICAgIC0gQXBwbGljYXRpb24gbmFtZTogTVVOIENvbm5lY3RcbiAqICAgIC0gQXV0aG9yaXplZCBkb21haW5zOiB5b3VyLWRvbWFpbi5jb21cbiAqICAgIC0gRGV2ZWxvcGVyIGNvbnRhY3QgaW5mb3JtYXRpb246IHlvdXItZW1haWxAZXhhbXBsZS5jb21cbiAqIDQuIENyZWF0ZSBPQXV0aCAyLjAgY3JlZGVudGlhbHNcbiAqICAgIC0gQXBwbGljYXRpb24gdHlwZTogV2ViIGFwcGxpY2F0aW9uXG4gKiAgICAtIE5hbWU6IE1VTiBDb25uZWN0IFdlYiBDbGllbnRcbiAqICAgIC0gQXV0aG9yaXplZCBKYXZhU2NyaXB0IG9yaWdpbnM6IGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMCwgaHR0cHM6Ly95b3VyLWRvbWFpbi5jb21cbiAqICAgIC0gQXV0aG9yaXplZCByZWRpcmVjdCBVUklzOiBodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvY2FsbGJhY2svZ29vZ2xlLCBodHRwczovL3lvdXItZG9tYWluLmNvbS9hcGkvYXV0aC9jYWxsYmFjay9nb29nbGVcbiAqIDUuIEFkZCB0aGUgZm9sbG93aW5nIGVudmlyb25tZW50IHZhcmlhYmxlcyB0byB5b3VyIC5lbnYubG9jYWwgZmlsZTpcbiAqICAgIC0gR09PR0xFX0NMSUVOVF9JRD15b3VyLWNsaWVudC1pZFxuICogICAgLSBHT09HTEVfQ0xJRU5UX1NFQ1JFVD15b3VyLWNsaWVudC1zZWNyZXRcbiAqICAgIC0gR09PR0xFX0FQSV9LRVk9eW91ci1hcGkta2V5IChmb3IgcHVibGljIEFQSSBhY2Nlc3MpXG4gKi9cblxuaW1wb3J0IHsgRG9jdW1lbnQgfSBmcm9tICcuL2RvY3VtZW50JztcblxuLy8gQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBHb29nbGUgRHJpdmUgQVBJXG5pbnRlcmZhY2UgR29vZ2xlRHJpdmVDb25maWcge1xuICBjbGllbnRJZDogc3RyaW5nO1xuICBhcGlLZXk6IHN0cmluZztcbiAgc2NvcGVzOiBzdHJpbmdbXTtcbn1cblxuLy8gRGVmYXVsdCBjb25maWd1cmF0aW9uIC0gdGhlc2UgdmFsdWVzIHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIGVudmlyb25tZW50IHZhcmlhYmxlc1xuY29uc3QgREVGQVVMVF9DT05GSUc6IEdvb2dsZURyaXZlQ29uZmlnID0ge1xuICBjbGllbnRJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX0NMSUVOVF9JRCB8fCAnJyxcbiAgYXBpS2V5OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HT09HTEVfQVBJX0tFWSB8fCAnJyxcbiAgc2NvcGVzOiBbXG4gICAgJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZHJpdmUuZmlsZScsXG4gICAgJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZHJpdmUuYXBwZGF0YScsXG4gIF0sXG59O1xuXG4vLyBHb29nbGUgRHJpdmUgQVBJIFNlcnZpY2VcbmV4cG9ydCBjbGFzcyBHb29nbGVEcml2ZVNlcnZpY2Uge1xuICBwcml2YXRlIGdhcGlMb2FkZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBnaXNMb2FkZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSB0b2tlbkNsaWVudDogYW55ID0gbnVsbDtcbiAgcHJpdmF0ZSBhY2Nlc3NUb2tlbjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgY29uZmlnOiBHb29nbGVEcml2ZUNvbmZpZztcbiAgXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogUGFydGlhbDxHb29nbGVEcml2ZUNvbmZpZz4gPSB7fSkge1xuICAgIHRoaXMuY29uZmlnID0geyAuLi5ERUZBVUxUX0NPTkZJRywgLi4uY29uZmlnIH07XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBHb29nbGUgRHJpdmUgQVBJXG4gICAqIFRoaXMgbG9hZHMgdGhlIHJlcXVpcmVkIGxpYnJhcmllcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIEFQSSBjbGllbnRcbiAgICovXG4gIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIExvYWQgdGhlIEdvb2dsZSBBUEkgY2xpZW50IGxpYnJhcnlcbiAgICAgICAgY29uc3Qgc2NyaXB0MSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHQxLnNyYyA9ICdodHRwczovL2FwaXMuZ29vZ2xlLmNvbS9qcy9hcGkuanMnO1xuICAgICAgICBzY3JpcHQxLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmdhcGlMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMubG9hZEdhcGlDbGllbnQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdpc0xvYWRlZCkgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBzY3JpcHQxLm9uZXJyb3IgPSAoZXJyb3IpID0+IHJlamVjdChgRmFpbGVkIHRvIGxvYWQgR29vZ2xlIEFQSSBjbGllbnQ6ICR7ZXJyb3J9YCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0MSk7XG4gICAgICAgIFxuICAgICAgICAvLyBMb2FkIHRoZSBHb29nbGUgSWRlbnRpdHkgU2VydmljZXMgbGlicmFyeVxuICAgICAgICBjb25zdCBzY3JpcHQyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdDIuc3JjID0gJ2h0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbS9nc2kvY2xpZW50JztcbiAgICAgICAgc2NyaXB0Mi5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5naXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZVRva2VuQ2xpZW50KCk7XG4gICAgICAgICAgaWYgKHRoaXMuZ2FwaUxvYWRlZCkgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBzY3JpcHQyLm9uZXJyb3IgPSAoZXJyb3IpID0+IHJlamVjdChgRmFpbGVkIHRvIGxvYWQgR29vZ2xlIElkZW50aXR5IFNlcnZpY2VzOiAke2Vycm9yfWApO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdDIpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGBFcnJvciBpbml0aWFsaXppbmcgR29vZ2xlIERyaXZlIEFQSTogJHtlcnJvcn1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIExvYWQgdGhlIEdvb2dsZSBBUEkgY2xpZW50IGxpYnJhcnlcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgbG9hZEdhcGlDbGllbnQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdpbmRvdy5nYXBpLmxvYWQoJ2NsaWVudCcsIHtcbiAgICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgd2luZG93LmdhcGkuY2xpZW50LmluaXQoe1xuICAgICAgICAgICAgICAgIGFwaUtleTogdGhpcy5jb25maWcuYXBpS2V5LFxuICAgICAgICAgICAgICAgIGRpc2NvdmVyeURvY3M6IFsnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vZGlzY292ZXJ5L3YxL2FwaXMvZHJpdmUvdjMvcmVzdCddLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGBFcnJvciBpbml0aWFsaXppbmcgR0FQSSBjbGllbnQ6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbmVycm9yOiAoZXJyb3I6IGFueSkgPT4gcmVqZWN0KGBFcnJvciBsb2FkaW5nIEdBUEkgY2xpZW50OiAke2Vycm9yfWApLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChgRmFpbGVkIHRvIGxvYWQgR0FQSSBjbGllbnQ6ICR7ZXJyb3J9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBHb29nbGUgSWRlbnRpdHkgU2VydmljZXMgdG9rZW4gY2xpZW50XG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVUb2tlbkNsaWVudCgpOiB2b2lkIHtcbiAgICB0aGlzLnRva2VuQ2xpZW50ID0gd2luZG93Lmdvb2dsZS5hY2NvdW50cy5vYXV0aDIuaW5pdFRva2VuQ2xpZW50KHtcbiAgICAgIGNsaWVudF9pZDogdGhpcy5jb25maWcuY2xpZW50SWQsXG4gICAgICBzY29wZTogdGhpcy5jb25maWcuc2NvcGVzLmpvaW4oJyAnKSxcbiAgICAgIGNhbGxiYWNrOiAodG9rZW5SZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgIGlmICh0b2tlblJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2V0dGluZyBhY2Nlc3MgdG9rZW46ICR7dG9rZW5SZXNwb25zZS5lcnJvcn1gKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHRva2VuUmVzcG9uc2UuYWNjZXNzX3Rva2VuO1xuICAgICAgICB3aW5kb3cuZ2FwaS5jbGllbnQuc2V0VG9rZW4odG9rZW5SZXNwb25zZSk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogQXV0aGVudGljYXRlIHRoZSB1c2VyIGFuZCByZXF1ZXN0IGFjY2VzcyB0byBHb29nbGUgRHJpdmVcbiAgICovXG4gIGFzeW5jIGF1dGhlbnRpY2F0ZSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGlmICghdGhpcy50b2tlbkNsaWVudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUb2tlbiBjbGllbnQgbm90IGluaXRpYWxpemVkJyk7XG4gICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMudG9rZW5DbGllbnQuY2FsbGJhY2sgPSAocmVzcDogYW55KSA9PiB7XG4gICAgICAgICAgaWYgKHJlc3AuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGR1cmluZyBhdXRoZW50aWNhdGlvbjogJHtyZXNwLmVycm9yfWApO1xuICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSByZXNwLmFjY2Vzc190b2tlbjtcbiAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgaWYgKHdpbmRvdy5nYXBpLmNsaWVudC5nZXRUb2tlbigpID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gUmVxdWVzdCBhbiBhY2Nlc3MgdG9rZW5cbiAgICAgICAgICB0aGlzLnRva2VuQ2xpZW50LnJlcXVlc3RBY2Nlc3NUb2tlbih7IHByb21wdDogJ2NvbnNlbnQnIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFscmVhZHkgaGF2ZSBhbiBhY2Nlc3MgdG9rZW5cbiAgICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gd2luZG93LmdhcGkuY2xpZW50LmdldFRva2VuKCkuYWNjZXNzX3Rva2VuO1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGF1dGhlbnRpY2F0aW5nOiAke2Vycm9yfWApO1xuICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB1c2VyIGlzIGF1dGhlbnRpY2F0ZWRcbiAgICovXG4gIGlzQXV0aGVudGljYXRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hY2Nlc3NUb2tlbiAhPT0gbnVsbDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBHb29nbGUgRG9jIGZvciBhIGRvY3VtZW50XG4gICAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gY3JlYXRlIGEgR29vZ2xlIERvYyBmb3JcbiAgICogQHJldHVybnMgVGhlIElEIG9mIHRoZSBjcmVhdGVkIEdvb2dsZSBEb2NcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUdvb2dsZURvYyhkb2N1bWVudDogRG9jdW1lbnQpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICghdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCB3aXRoIEdvb2dsZSBEcml2ZScpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cuZ2FwaS5jbGllbnQuZHJpdmUuZmlsZXMuY3JlYXRlKHtcbiAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICBuYW1lOiBkb2N1bWVudC50aXRsZSxcbiAgICAgICAgICBtaW1lVHlwZTogJ2FwcGxpY2F0aW9uL3ZuZC5nb29nbGUtYXBwcy5kb2N1bWVudCcsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBNVU4gQ29ubmVjdCBkb2N1bWVudDogJHtkb2N1bWVudC50eXBlfSBmb3IgJHtkb2N1bWVudC5jb21taXR0ZWV9IC0gJHtkb2N1bWVudC5jb3VudHJ5fWAsXG4gICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgbXVuQ29ubmVjdERvY0lkOiBkb2N1bWVudC5pZCxcbiAgICAgICAgICAgIGRvY3VtZW50VHlwZTogZG9jdW1lbnQudHlwZSxcbiAgICAgICAgICAgIGNvbW1pdHRlZTogZG9jdW1lbnQuY29tbWl0dGVlLFxuICAgICAgICAgICAgY291bnRyeTogZG9jdW1lbnQuY291bnRyeSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBmaWVsZHM6ICdpZCx3ZWJWaWV3TGluaycsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdC5pZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY3JlYXRpbmcgR29vZ2xlIERvYzogJHtlcnJvcn1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBHb29nbGUgRG9jOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBhIEdvb2dsZSBEb2MgYnkgaXRzIElEXG4gICAqIEBwYXJhbSBnb29nbGVEb2NJZCBUaGUgSUQgb2YgdGhlIEdvb2dsZSBEb2MgdG8gZ2V0XG4gICAqIEByZXR1cm5zIFRoZSBHb29nbGUgRG9jIG1ldGFkYXRhXG4gICAqL1xuICBhc3luYyBnZXRHb29nbGVEb2MoZ29vZ2xlRG9jSWQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCF0aGlzLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRoZW50aWNhdGVkIHdpdGggR29vZ2xlIERyaXZlJyk7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5nYXBpLmNsaWVudC5kcml2ZS5maWxlcy5nZXQoe1xuICAgICAgICBmaWxlSWQ6IGdvb2dsZURvY0lkLFxuICAgICAgICBmaWVsZHM6ICdpZCxuYW1lLHdlYlZpZXdMaW5rLG1vZGlmaWVkVGltZSxjYXBhYmlsaXRpZXMnLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGdldHRpbmcgR29vZ2xlIERvYzogJHtlcnJvcn1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBHb29nbGUgRG9jOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFVwZGF0ZSBhIEdvb2dsZSBEb2MncyBjb250ZW50XG4gICAqIEBwYXJhbSBnb29nbGVEb2NJZCBUaGUgSUQgb2YgdGhlIEdvb2dsZSBEb2MgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSBjb250ZW50IFRoZSBuZXcgY29udGVudCBvZiB0aGUgR29vZ2xlIERvY1xuICAgKi9cbiAgYXN5bmMgdXBkYXRlR29vZ2xlRG9jKGdvb2dsZURvY0lkOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCB3aXRoIEdvb2dsZSBEcml2ZScpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgdmVyc2lvbi4gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLFxuICAgICAgLy8geW91IHdvdWxkIHVzZSB0aGUgR29vZ2xlIERvY3MgQVBJIHRvIHVwZGF0ZSB0aGUgZG9jdW1lbnQgY29udGVudC5cbiAgICAgIC8vIEZvciBzaW1wbGljaXR5LCB3ZSdyZSBqdXN0IHVwZGF0aW5nIHRoZSBkb2N1bWVudCdzIG1ldGFkYXRhIGhlcmUuXG4gICAgICBhd2FpdCB3aW5kb3cuZ2FwaS5jbGllbnQuZHJpdmUuZmlsZXMudXBkYXRlKHtcbiAgICAgICAgZmlsZUlkOiBnb29nbGVEb2NJZCxcbiAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgdXBkYXRpbmcgR29vZ2xlIERvYzogJHtlcnJvcn1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSBHb29nbGUgRG9jOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEV4cG9ydCBhIEdvb2dsZSBEb2MgdG8gYSBzcGVjaWZpYyBmb3JtYXQgKFBERiwgRE9DWClcbiAgICogQHBhcmFtIGdvb2dsZURvY0lkIFRoZSBJRCBvZiB0aGUgR29vZ2xlIERvYyB0byBleHBvcnRcbiAgICogQHBhcmFtIG1pbWVUeXBlIFRoZSBtaW1lIHR5cGUgdG8gZXhwb3J0IHRvIChlLmcuLCAnYXBwbGljYXRpb24vcGRmJylcbiAgICogQHJldHVybnMgQSBVUkwgdG8gZG93bmxvYWQgdGhlIGV4cG9ydGVkIGZpbGVcbiAgICovXG4gIGFzeW5jIGV4cG9ydEdvb2dsZURvYyhnb29nbGVEb2NJZDogc3RyaW5nLCBtaW1lVHlwZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuaXNBdXRoZW50aWNhdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhlbnRpY2F0ZWQgd2l0aCBHb29nbGUgRHJpdmUnKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgIGBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9kcml2ZS92My9maWxlcy8ke2dvb2dsZURvY0lkfS9leHBvcnQ/bWltZVR5cGU9JHtlbmNvZGVVUklDb21wb25lbnQobWltZVR5cGUpfWAsXG4gICAgICAgIHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5hY2Nlc3NUb2tlbn1gLFxuICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZXhwb3J0IEdvb2dsZSBEb2M6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBleHBvcnRpbmcgR29vZ2xlIERvYzogJHtlcnJvcn1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGV4cG9ydCBHb29nbGUgRG9jOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFdhdGNoIGZvciBjaGFuZ2VzIHRvIGEgR29vZ2xlIERvY1xuICAgKiBUaGlzIGlzIGEgcGxhY2Vob2xkZXIgZm9yIHJlYWwtdGltZSBzeW5jIGZ1bmN0aW9uYWxpdHkuXG4gICAqIEluIGEgcHJvZHVjdGlvbiBlbnZpcm9ubWVudCwgeW91IHdvdWxkIHVzZSB0aGUgR29vZ2xlIERyaXZlIEFQSSdzXG4gICAqIHdhdGNoIG1ldGhvZCBvciBlc3RhYmxpc2ggYSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgICogXG4gICAqIEBwYXJhbSBnb29nbGVEb2NJZCBUaGUgSUQgb2YgdGhlIEdvb2dsZSBEb2MgdG8gd2F0Y2hcbiAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gdGhlIEdvb2dsZSBEb2MgY2hhbmdlc1xuICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRvIHN0b3Agd2F0Y2hpbmcgZm9yIGNoYW5nZXNcbiAgICovXG4gIHdhdGNoR29vZ2xlRG9jKGdvb2dsZURvY0lkOiBzdHJpbmcsIGNhbGxiYWNrOiAoY2hhbmdlczogYW55KSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gICAgLy8gVGhpcyBpcyBhIHBsYWNlaG9sZGVyLiBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHlvdSB3b3VsZCB1c2UgdGhlIEdvb2dsZSBEcml2ZSBBUEknc1xuICAgIC8vIGNoYW5nZXMud2F0Y2ggbWV0aG9kIG9yIGVzdGFibGlzaCBhIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgIGNvbnN0IGNoZWNrSW50ZXJ2YWwgPSA1MDAwOyAvLyBDaGVjayBldmVyeSA1IHNlY29uZHNcbiAgICBsZXQgbGFzdE1vZGlmaWVkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICBcbiAgICBjb25zdCBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdOb3QgYXV0aGVudGljYXRlZCB3aXRoIEdvb2dsZSBEcml2ZScpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgZG9jID0gYXdhaXQgdGhpcy5nZXRHb29nbGVEb2MoZ29vZ2xlRG9jSWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGxhc3RNb2RpZmllZCAhPT0gbnVsbCAmJiBkb2MubW9kaWZpZWRUaW1lICE9PSBsYXN0TW9kaWZpZWQpIHtcbiAgICAgICAgICAvLyBEb2N1bWVudCBoYXMgY2hhbmdlZFxuICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgIGRvY3VtZW50SWQ6IGdvb2dsZURvY0lkLFxuICAgICAgICAgICAgbW9kaWZpZWRUaW1lOiBkb2MubW9kaWZpZWRUaW1lLFxuICAgICAgICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB5b3Ugd291bGQgaW5jbHVkZSB0aGUgYWN0dWFsIGNoYW5nZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbGFzdE1vZGlmaWVkID0gZG9jLm1vZGlmaWVkVGltZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNoZWNraW5nIGZvciBHb29nbGUgRG9jIGNoYW5nZXM6ICR7ZXJyb3J9YCk7XG4gICAgICB9XG4gICAgfSwgY2hlY2tJbnRlcnZhbCk7XG4gICAgXG4gICAgLy8gUmV0dXJuIGEgZnVuY3Rpb24gdG8gc3RvcCB3YXRjaGluZyBmb3IgY2hhbmdlc1xuICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICB9XG4gIFxuICAvKipcbiAgICogSW1wb3J0IGEgZmlsZSBmcm9tIEdvb2dsZSBEcml2ZVxuICAgKiBAcGFyYW0gZmlsZUlkIFRoZSBJRCBvZiB0aGUgZmlsZSB0byBpbXBvcnRcbiAgICogQHJldHVybnMgVGhlIGltcG9ydGVkIGZpbGUgZGF0YVxuICAgKi9cbiAgYXN5bmMgaW1wb3J0RmlsZShmaWxlSWQ6IHN0cmluZyk6IFByb21pc2U8eyBuYW1lOiBzdHJpbmc7IGNvbnRlbnQ6IHN0cmluZzsgbWltZVR5cGU6IHN0cmluZyB9PiB7XG4gICAgaWYgKCF0aGlzLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRoZW50aWNhdGVkIHdpdGggR29vZ2xlIERyaXZlJyk7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgZmlsZSBtZXRhZGF0YVxuICAgICAgY29uc3QgbWV0YWRhdGFSZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5nYXBpLmNsaWVudC5kcml2ZS5maWxlcy5nZXQoe1xuICAgICAgICBmaWxlSWQsXG4gICAgICAgIGZpZWxkczogJ25hbWUsbWltZVR5cGUnLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgbmFtZSwgbWltZVR5cGUgfSA9IG1ldGFkYXRhUmVzcG9uc2UucmVzdWx0O1xuICAgICAgXG4gICAgICAvLyBHZXQgZmlsZSBjb250ZW50XG4gICAgICBjb25zdCBjb250ZW50UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2RyaXZlL3YzL2ZpbGVzLyR7ZmlsZUlkfT9hbHQ9bWVkaWFgLFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuYWNjZXNzVG9rZW59YCxcbiAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAoIWNvbnRlbnRSZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgZmlsZSBjb250ZW50OiAke2NvbnRlbnRSZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBsZXQgY29udGVudCA9ICcnO1xuICAgICAgXG4gICAgICBpZiAobWltZVR5cGUgPT09ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWFwcHMuZG9jdW1lbnQnKSB7XG4gICAgICAgIC8vIEV4cG9ydCBHb29nbGUgRG9jIHRvIHRleHRcbiAgICAgICAgY29uc3QgZXhwb3J0VXJsID0gYXdhaXQgdGhpcy5leHBvcnRHb29nbGVEb2MoZmlsZUlkLCAndGV4dC9wbGFpbicpO1xuICAgICAgICBjb25zdCBleHBvcnRSZXNwb25zZSA9IGF3YWl0IGZldGNoKGV4cG9ydFVybCk7XG4gICAgICAgIGNvbnRlbnQgPSBhd2FpdCBleHBvcnRSZXNwb25zZS50ZXh0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHZXQgcmF3IGNvbnRlbnQgZm9yIG90aGVyIGZpbGUgdHlwZXNcbiAgICAgICAgY29udGVudCA9IGF3YWl0IGNvbnRlbnRSZXNwb25zZS50ZXh0KCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7IG5hbWUsIGNvbnRlbnQsIG1pbWVUeXBlIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGltcG9ydGluZyBmaWxlOiAke2Vycm9yfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gaW1wb3J0IGZpbGU6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgZmlsZXMgZnJvbSBHb29nbGUgRHJpdmVcbiAgICogQHBhcmFtIHF1ZXJ5IE9wdGlvbmFsIHNlYXJjaCBxdWVyeSB0byBmaWx0ZXIgZmlsZXNcbiAgICogQHJldHVybnMgQXJyYXkgb2YgR29vZ2xlIERyaXZlIGZpbGVzXG4gICAqL1xuICBhc3luYyBsaXN0RHJpdmVGaWxlcyhxdWVyeTogc3RyaW5nID0gJycpIHtcbiAgICBpZiAoIXRoaXMuaXNBdXRoZW50aWNhdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhlbnRpY2F0ZWQgd2l0aCBHb29nbGUgRHJpdmUnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gVXNlIHRoZSBHb29nbGUgRHJpdmUgQVBJIHRvIGxpc3QgZmlsZXNcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgd2luZG93LmdhcGkuY2xpZW50LmRyaXZlLmZpbGVzLmxpc3Qoe1xuICAgICAgICBwYWdlU2l6ZTogNTAsXG4gICAgICAgIGZpZWxkczogJ2ZpbGVzKGlkLCBuYW1lLCBtaW1lVHlwZSwgbW9kaWZpZWRUaW1lLCB3ZWJWaWV3TGluayknLFxuICAgICAgICBxOiBxdWVyeSA/IHF1ZXJ5IDogJ3RyYXNoZWQgPSBmYWxzZScsXG4gICAgICAgIG9yZGVyQnk6ICdtb2RpZmllZFRpbWUgZGVzYydcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZygnR29vZ2xlIERyaXZlIGZpbGVzOicsIHJlc3BvbnNlLnJlc3VsdC5maWxlcyk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0LmZpbGVzIHx8IFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsaXN0aW5nIERyaXZlIGZpbGVzOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFJIENvbmZsaWN0IERldGVjdGlvbiBTZXJ2aWNlXG4gKiBcbiAqIFRoaXMgc2VydmljZSBpbXBsZW1lbnRzIGEgYmFzaWMgQUkgY29uZmxpY3QgZGV0ZWN0aW9uIGFsZ29yaXRobVxuICogdG8gZmxhZyBjb25mbGljdHMgYmV0d2VlbiBkb2N1bWVudHMgb3IgY29udGVudCBzZWN0aW9ucy5cbiAqIFxuICogSW4gYSBwcm9kdWN0aW9uIGVudmlyb25tZW50LCB0aGlzIHdvdWxkIGludGVncmF0ZSB3aXRoIGFuXG4gKiBhY3R1YWwgTkxQIG9yIEFJIHNlcnZpY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25mbGljdERldGVjdGlvblNlcnZpY2Uge1xuICAvKipcbiAgICogRGV0ZWN0IGNvbmZsaWN0cyBiZXR3ZWVuIGRvY3VtZW50IGNvbnRlbnQgc2VjdGlvbnNcbiAgICogQHBhcmFtIGNvbnRlbnRBIEZpcnN0IGNvbnRlbnQgc2VjdGlvblxuICAgKiBAcGFyYW0gY29udGVudEIgU2Vjb25kIGNvbnRlbnQgc2VjdGlvblxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBkZXRlY3RlZCBjb25mbGljdHNcbiAgICovXG4gIGRldGVjdENvbmZsaWN0cyhjb250ZW50QTogc3RyaW5nLCBjb250ZW50Qjogc3RyaW5nKTogQXJyYXk8e1xuICAgIHR5cGU6ICdkdXBsaWNhdGVfY29udGVudCcgfCAnY29uZmxpY3RpbmdfcGVyc3BlY3RpdmUnO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgc2VjdGlvbnM6IHN0cmluZ1tdO1xuICB9PiB7XG4gICAgY29uc3QgY29uZmxpY3RzOiBBcnJheTx7XG4gICAgICB0eXBlOiAnZHVwbGljYXRlX2NvbnRlbnQnIHwgJ2NvbmZsaWN0aW5nX3BlcnNwZWN0aXZlJztcbiAgICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgICBzZWN0aW9uczogc3RyaW5nW107XG4gICAgfT4gPSBbXTtcbiAgICBcbiAgICAvLyBUaGlzIGlzIGEgdmVyeSBiYXNpYyBpbXBsZW1lbnRhdGlvbiBmb3IgZGVtb25zdHJhdGlvbiBwdXJwb3Nlc1xuICAgIFxuICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgY29udGVudCAoZXhhY3QgbWF0Y2hlcylcbiAgICBjb25zdCBwYXJhZ3JhcGhzQSA9IGNvbnRlbnRBLnNwbGl0KCdcXG5cXG4nKTtcbiAgICBjb25zdCBwYXJhZ3JhcGhzQiA9IGNvbnRlbnRCLnNwbGl0KCdcXG5cXG4nKTtcbiAgICBcbiAgICAvLyBDb21wYXJlIHBhcmFncmFwaHMgZm9yIGV4YWN0IG1hdGNoZXMgKHNpbXVsYXRpbmcgZHVwbGljYXRlIGNvbnRlbnQgZGV0ZWN0aW9uKVxuICAgIGZvciAoY29uc3QgcGFyYUEgb2YgcGFyYWdyYXBoc0EpIHtcbiAgICAgIGlmIChwYXJhQS5sZW5ndGggPiA1MCAmJiBwYXJhZ3JhcGhzQi5pbmNsdWRlcyhwYXJhQSkpIHtcbiAgICAgICAgY29uZmxpY3RzLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdkdXBsaWNhdGVfY29udGVudCcsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdEdXBsaWNhdGUgcGFyYWdyYXBoIGRldGVjdGVkJyxcbiAgICAgICAgICBzZWN0aW9uczogW3BhcmFBXSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFNpbXVsYXRpbmcgY29uZmxpY3RpbmcgcGVyc3BlY3RpdmUgZGV0ZWN0aW9uXG4gICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIHVzZSBOTFAgdG8gZGV0ZWN0IGNvbnRyYWRpY3Rvcnkgc3RhdGVtZW50c1xuICAgIGNvbnN0IGtleXdvcmRzQSA9IHRoaXMuZXh0cmFjdEtleXdvcmRzKGNvbnRlbnRBKTtcbiAgICBjb25zdCBrZXl3b3Jkc0IgPSB0aGlzLmV4dHJhY3RLZXl3b3Jkcyhjb250ZW50Qik7XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIG9wcG9zaXRlIHNlbnRpbWVudCBrZXl3b3JkcyAodmVyeSBzaW1wbGlmaWVkIGFwcHJvYWNoKVxuICAgIGNvbnN0IG9wcG9zaXRlS2V5d29yZHMgPSBbXG4gICAgICBbJ3N1cHBvcnQnLCAnb3Bwb3NlJ10sXG4gICAgICBbJ2FncmVlJywgJ2Rpc2FncmVlJ10sXG4gICAgICBbJ2FwcHJvdmUnLCAnZGlzYXBwcm92ZSddLFxuICAgICAgWydpbmNyZWFzZScsICdkZWNyZWFzZSddLFxuICAgICAgWydwb3NpdGl2ZScsICduZWdhdGl2ZSddLFxuICAgIF07XG4gICAgXG4gICAgZm9yIChjb25zdCBbcG9zaXRpdmUsIG5lZ2F0aXZlXSBvZiBvcHBvc2l0ZUtleXdvcmRzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChrZXl3b3Jkc0EuaW5jbHVkZXMocG9zaXRpdmUpICYmIGtleXdvcmRzQi5pbmNsdWRlcyhuZWdhdGl2ZSkpIHx8XG4gICAgICAgIChrZXl3b3Jkc0EuaW5jbHVkZXMobmVnYXRpdmUpICYmIGtleXdvcmRzQi5pbmNsdWRlcyhwb3NpdGl2ZSkpXG4gICAgICApIHtcbiAgICAgICAgY29uZmxpY3RzLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdjb25mbGljdGluZ19wZXJzcGVjdGl2ZScsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBQb3RlbnRpYWxseSBjb25mbGljdGluZyBwb3NpdGlvbnM6IFwiJHtwb3NpdGl2ZX1cIiB2cyBcIiR7bmVnYXRpdmV9XCJgLFxuICAgICAgICAgIHNlY3Rpb25zOiB0aGlzLmZpbmRTZW50ZW5jZXNXaXRoS2V5d29yZHMoXG4gICAgICAgICAgICBbY29udGVudEEsIGNvbnRlbnRCXSxcbiAgICAgICAgICAgIFtwb3NpdGl2ZSwgbmVnYXRpdmVdXG4gICAgICAgICAgKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjb25mbGljdHM7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBFeHRyYWN0IGtleXdvcmRzIGZyb20gdGV4dCAoc2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbilcbiAgICogQHBhcmFtIHRleHQgVGhlIHRleHQgdG8gZXh0cmFjdCBrZXl3b3JkcyBmcm9tXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGV4dHJhY3RlZCBrZXl3b3Jkc1xuICAgKi9cbiAgcHJpdmF0ZSBleHRyYWN0S2V5d29yZHModGV4dDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uLlxuICAgIC8vIEluIGEgcmVhbCBhcHAsIHlvdSB3b3VsZCB1c2UgYSBwcm9wZXIgTkxQIGxpYnJhcnkgZm9yIGtleXdvcmQgZXh0cmFjdGlvbi5cbiAgICBjb25zdCB3b3JkcyA9IHRleHQudG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxXKy8pO1xuICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQod29yZHMuZmlsdGVyKHdvcmQgPT4gd29yZC5sZW5ndGggPiAzKSkpO1xuICB9XG4gIFxuICAvKipcbiAgICogRmluZCBzZW50ZW5jZXMgY29udGFpbmluZyBzcGVjaWZpYyBrZXl3b3Jkc1xuICAgKiBAcGFyYW0gdGV4dHMgQXJyYXkgb2YgdGV4dCBibG9ja3MgdG8gc2VhcmNoIGluXG4gICAqIEBwYXJhbSBrZXl3b3JkcyBLZXl3b3JkcyB0byBzZWFyY2ggZm9yXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIHNlbnRlbmNlcyBjb250YWluaW5nIHRoZSBrZXl3b3Jkc1xuICAgKi9cbiAgcHJpdmF0ZSBmaW5kU2VudGVuY2VzV2l0aEtleXdvcmRzKHRleHRzOiBzdHJpbmdbXSwga2V5d29yZHM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHNlbnRlbmNlczogc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICAvLyBTcGxpdCB0ZXh0cyBpbnRvIHNlbnRlbmNlcyBhbmQgZmluZCB0aG9zZSBjb250YWluaW5nIGtleXdvcmRzXG4gICAgZm9yIChjb25zdCB0ZXh0IG9mIHRleHRzKSB7XG4gICAgICBjb25zdCB0ZXh0U2VudGVuY2VzID0gdGV4dC5zcGxpdCgvWy4hP10rLykuZmlsdGVyKHMgPT4gcy50cmltKCkubGVuZ3RoID4gMCk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3Qgc2VudGVuY2Ugb2YgdGV4dFNlbnRlbmNlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleXdvcmQgb2Yga2V5d29yZHMpIHtcbiAgICAgICAgICBpZiAoc2VudGVuY2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhrZXl3b3JkLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICBzZW50ZW5jZXMucHVzaChzZW50ZW5jZS50cmltKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzZW50ZW5jZXM7XG4gIH1cbn1cblxuLy8gQ3JlYXRlIHNpbmdsZXRvbiBpbnN0YW5jZXMgZm9yIHVzZSB0aHJvdWdob3V0IHRoZSBhcHBsaWNhdGlvblxuZXhwb3J0IGNvbnN0IGdvb2dsZURyaXZlU2VydmljZSA9IG5ldyBHb29nbGVEcml2ZVNlcnZpY2UoKTtcbmV4cG9ydCBjb25zdCBjb25mbGljdERldGVjdGlvblNlcnZpY2UgPSBuZXcgQ29uZmxpY3REZXRlY3Rpb25TZXJ2aWNlKCk7XG5cbi8vIEFkZCBUeXBlU2NyaXB0IGludGVyZmFjZXMgZm9yIEdvb2dsZSBBUEkgd2luZG93cyByZWZlcmVuY2VzXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIGdhcGk6IGFueTtcbiAgICBnb29nbGU6IGFueTtcbiAgfVxufSAiXSwibmFtZXMiOlsiREVGQVVMVF9DT05GSUciLCJjbGllbnRJZCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19HT09HTEVfQ0xJRU5UX0lEIiwiYXBpS2V5IiwiTkVYVF9QVUJMSUNfR09PR0xFX0FQSV9LRVkiLCJzY29wZXMiLCJHb29nbGVEcml2ZVNlcnZpY2UiLCJpbml0aWFsaXplIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzY3JpcHQxIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwib25sb2FkIiwiZ2FwaUxvYWRlZCIsImxvYWRHYXBpQ2xpZW50IiwidGhlbiIsImdpc0xvYWRlZCIsIm9uZXJyb3IiLCJlcnJvciIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInNjcmlwdDIiLCJpbml0aWFsaXplVG9rZW5DbGllbnQiLCJ3aW5kb3ciLCJnYXBpIiwibG9hZCIsImNhbGxiYWNrIiwiY2xpZW50IiwiaW5pdCIsImNvbmZpZyIsImRpc2NvdmVyeURvY3MiLCJ0b2tlbkNsaWVudCIsImdvb2dsZSIsImFjY291bnRzIiwib2F1dGgyIiwiaW5pdFRva2VuQ2xpZW50IiwiY2xpZW50X2lkIiwic2NvcGUiLCJqb2luIiwidG9rZW5SZXNwb25zZSIsImNvbnNvbGUiLCJhY2Nlc3NUb2tlbiIsImFjY2Vzc190b2tlbiIsInNldFRva2VuIiwiYXV0aGVudGljYXRlIiwicmVzcCIsImdldFRva2VuIiwicmVxdWVzdEFjY2Vzc1Rva2VuIiwicHJvbXB0IiwiaXNBdXRoZW50aWNhdGVkIiwiY3JlYXRlR29vZ2xlRG9jIiwiRXJyb3IiLCJyZXNwb25zZSIsImRyaXZlIiwiZmlsZXMiLCJjcmVhdGUiLCJyZXNvdXJjZSIsIm5hbWUiLCJ0aXRsZSIsIm1pbWVUeXBlIiwiZGVzY3JpcHRpb24iLCJ0eXBlIiwiY29tbWl0dGVlIiwiY291bnRyeSIsInByb3BlcnRpZXMiLCJtdW5Db25uZWN0RG9jSWQiLCJpZCIsImRvY3VtZW50VHlwZSIsImZpZWxkcyIsInJlc3VsdCIsImdldEdvb2dsZURvYyIsImdvb2dsZURvY0lkIiwiZ2V0IiwiZmlsZUlkIiwidXBkYXRlR29vZ2xlRG9jIiwiY29udGVudCIsInVwZGF0ZSIsImxhc3RVcGRhdGVkIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiZXhwb3J0R29vZ2xlRG9jIiwiZmV0Y2giLCJlbmNvZGVVUklDb21wb25lbnQiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsIm9rIiwic3RhdHVzVGV4dCIsImJsb2IiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJ3YXRjaEdvb2dsZURvYyIsImNoZWNrSW50ZXJ2YWwiLCJsYXN0TW9kaWZpZWQiLCJpbnRlcnZhbElkIiwic2V0SW50ZXJ2YWwiLCJ3YXJuIiwiZG9jIiwibW9kaWZpZWRUaW1lIiwiZG9jdW1lbnRJZCIsImNsZWFySW50ZXJ2YWwiLCJpbXBvcnRGaWxlIiwibWV0YWRhdGFSZXNwb25zZSIsImNvbnRlbnRSZXNwb25zZSIsImV4cG9ydFVybCIsImV4cG9ydFJlc3BvbnNlIiwidGV4dCIsImxpc3REcml2ZUZpbGVzIiwicXVlcnkiLCJsaXN0IiwicGFnZVNpemUiLCJxIiwib3JkZXJCeSIsImxvZyIsImNvbnN0cnVjdG9yIiwiQ29uZmxpY3REZXRlY3Rpb25TZXJ2aWNlIiwiZGV0ZWN0Q29uZmxpY3RzIiwiY29udGVudEEiLCJjb250ZW50QiIsImNvbmZsaWN0cyIsInBhcmFncmFwaHNBIiwic3BsaXQiLCJwYXJhZ3JhcGhzQiIsInBhcmFBIiwibGVuZ3RoIiwiaW5jbHVkZXMiLCJwdXNoIiwic2VjdGlvbnMiLCJrZXl3b3Jkc0EiLCJleHRyYWN0S2V5d29yZHMiLCJrZXl3b3Jkc0IiLCJvcHBvc2l0ZUtleXdvcmRzIiwicG9zaXRpdmUiLCJuZWdhdGl2ZSIsImZpbmRTZW50ZW5jZXNXaXRoS2V5d29yZHMiLCJ3b3JkcyIsInRvTG93ZXJDYXNlIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwiZmlsdGVyIiwid29yZCIsInRleHRzIiwia2V5d29yZHMiLCJzZW50ZW5jZXMiLCJ0ZXh0U2VudGVuY2VzIiwicyIsInRyaW0iLCJzZW50ZW5jZSIsImtleXdvcmQiLCJnb29nbGVEcml2ZVNlcnZpY2UiLCJjb25mbGljdERldGVjdGlvblNlcnZpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/googleDrive.ts\n"));

/***/ })

});