"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/repository/page",{

/***/ "(app-pages-browser)/./lib/googleDrive.ts":
/*!****************************!*\
  !*** ./lib/googleDrive.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConflictDetectionService: function() { return /* binding */ ConflictDetectionService; },\n/* harmony export */   GoogleDriveService: function() { return /* binding */ GoogleDriveService; },\n/* harmony export */   conflictDetectionService: function() { return /* binding */ conflictDetectionService; },\n/* harmony export */   googleDriveService: function() { return /* binding */ googleDriveService; }\n/* harmony export */ });\n/**\n * Google Drive API Integration Service\n * \n * This service handles the integration with Google Drive API for document management\n * and real-time collaboration.\n * \n * Google Cloud Project Setup Instructions:\n * 1. Create a new project in Google Cloud Console (https://console.cloud.google.com/)\n * 2. Enable the Google Drive API\n * 3. Configure OAuth consent screen\n *    - User Type: External\n *    - Application name: MUN Connect\n *    - Authorized domains: your-domain.com\n *    - Developer contact information: your-email@example.com\n * 4. Create OAuth 2.0 credentials\n *    - Application type: Web application\n *    - Name: MUN Connect Web Client\n *    - Authorized JavaScript origins: http://localhost:3000, https://your-domain.com\n *    - Authorized redirect URIs: http://localhost:3000/api/auth/callback/google, https://your-domain.com/api/auth/callback/google\n * 5. Add the following environment variables to your .env.local file:\n *    - GOOGLE_CLIENT_ID=your-client-id\n *    - GOOGLE_CLIENT_SECRET=your-client-secret\n *    - GOOGLE_API_KEY=your-api-key (for public API access)\n */ // Default configuration - these values should be replaced with environment variables\nconst DEFAULT_CONFIG = {\n    clientId: \"913358736520-5biusol4f5ead6t86d7rv94rd0ar3gkn.apps.googleusercontent.com\" || 0,\n    apiKey: \"AIzaSyB-pZ0FV758VUs_pIZ0Ck2iq5Wx0FDJCxw\" || 0,\n    scopes: [\n        \"https://www.googleapis.com/auth/drive.file\",\n        \"https://www.googleapis.com/auth/drive.appdata\"\n    ]\n};\n// Google Drive API Service\nclass GoogleDriveService {\n    /**\n   * Initialize the Google Drive API\n   * This loads the required libraries and initializes the API client\n   */ async initialize() {\n        return new Promise((resolve, reject)=>{\n            try {\n                // Load the Google API client library\n                const script1 = document.createElement(\"script\");\n                script1.src = \"https://apis.google.com/js/api.js\";\n                script1.onload = ()=>{\n                    this.gapiLoaded = true;\n                    this.loadGapiClient().then(()=>{\n                        if (this.gisLoaded) resolve();\n                    });\n                };\n                script1.onerror = (error)=>reject(\"Failed to load Google API client: \".concat(error));\n                document.body.appendChild(script1);\n                // Load the Google Identity Services library\n                const script2 = document.createElement(\"script\");\n                script2.src = \"https://accounts.google.com/gsi/client\";\n                script2.onload = ()=>{\n                    this.gisLoaded = true;\n                    this.initializeTokenClient();\n                    if (this.gapiLoaded) resolve();\n                };\n                script2.onerror = (error)=>reject(\"Failed to load Google Identity Services: \".concat(error));\n                document.body.appendChild(script2);\n            } catch (error) {\n                reject(\"Error initializing Google Drive API: \".concat(error));\n            }\n        });\n    }\n    /**\n   * Load the Google API client library\n   */ async loadGapiClient() {\n        return new Promise((resolve, reject)=>{\n            try {\n                window.gapi.load(\"client\", {\n                    callback: async ()=>{\n                        try {\n                            await window.gapi.client.init({\n                                apiKey: this.config.apiKey,\n                                discoveryDocs: [\n                                    \"https://www.googleapis.com/discovery/v1/apis/drive/v3/rest\"\n                                ]\n                            });\n                            resolve();\n                        } catch (error) {\n                            reject(\"Error initializing GAPI client: \".concat(error));\n                        }\n                    },\n                    onerror: (error)=>reject(\"Error loading GAPI client: \".concat(error))\n                });\n            } catch (error) {\n                reject(\"Failed to load GAPI client: \".concat(error));\n            }\n        });\n    }\n    /**\n   * Initialize the Google Identity Services token client\n   */ initializeTokenClient() {\n        this.tokenClient = window.google.accounts.oauth2.initTokenClient({\n            client_id: this.config.clientId,\n            scope: this.config.scopes.join(\" \"),\n            callback: (tokenResponse)=>{\n                if (tokenResponse.error) {\n                    console.error(\"Error getting access token: \".concat(tokenResponse.error));\n                    return;\n                }\n                this.accessToken = tokenResponse.access_token;\n                window.gapi.client.setToken(tokenResponse);\n            }\n        });\n    }\n    /**\n   * Authenticate the user and request access to Google Drive\n   */ async authenticate() {\n        return new Promise((resolve)=>{\n            if (!this.tokenClient) {\n                console.error(\"Token client not initialized\");\n                resolve(false);\n                return;\n            }\n            try {\n                this.tokenClient.callback = (resp)=>{\n                    if (resp.error) {\n                        console.error(\"Error during authentication: \".concat(resp.error));\n                        resolve(false);\n                        return;\n                    }\n                    this.accessToken = resp.access_token;\n                    resolve(true);\n                };\n                if (window.gapi.client.getToken() === null) {\n                    // Request an access token\n                    this.tokenClient.requestAccessToken({\n                        prompt: \"consent\"\n                    });\n                } else {\n                    // Already have an access token\n                    this.accessToken = window.gapi.client.getToken().access_token;\n                    resolve(true);\n                }\n            } catch (error) {\n                console.error(\"Error authenticating: \".concat(error));\n                resolve(false);\n            }\n        });\n    }\n    /**\n   * Check if the user is authenticated\n   */ isAuthenticated() {\n        return this.accessToken !== null;\n    }\n    /**\n   * Create a new Google Doc for a document\n   * @param document The document to create a Google Doc for\n   * @returns The ID of the created Google Doc\n   */ async createGoogleDoc(document1) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            const response = await window.gapi.client.drive.files.create({\n                resource: {\n                    name: document1.title,\n                    mimeType: \"application/vnd.google-apps.document\",\n                    description: \"MUN Connect document: \".concat(document1.type, \" for \").concat(document1.committee, \" - \").concat(document1.country),\n                    properties: {\n                        munConnectDocId: document1.id,\n                        documentType: document1.type,\n                        committee: document1.committee,\n                        country: document1.country\n                    }\n                },\n                fields: \"id,webViewLink\"\n            });\n            return response.result.id;\n        } catch (error) {\n            console.error(\"Error creating Google Doc: \".concat(error));\n            throw new Error(\"Failed to create Google Doc: \".concat(error));\n        }\n    }\n    /**\n   * Get a Google Doc by its ID\n   * @param googleDocId The ID of the Google Doc to get\n   * @returns The Google Doc metadata\n   */ async getGoogleDoc(googleDocId) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            const response = await window.gapi.client.drive.files.get({\n                fileId: googleDocId,\n                fields: \"id,name,webViewLink,modifiedTime,capabilities\"\n            });\n            return response.result;\n        } catch (error) {\n            console.error(\"Error getting Google Doc: \".concat(error));\n            throw new Error(\"Failed to get Google Doc: \".concat(error));\n        }\n    }\n    /**\n   * Update a Google Doc's content\n   * @param googleDocId The ID of the Google Doc to update\n   * @param content The new content of the Google Doc\n   */ async updateGoogleDoc(googleDocId, content) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            // This is a simplified version. In a real implementation,\n            // you would use the Google Docs API to update the document content.\n            // For simplicity, we're just updating the document's metadata here.\n            await window.gapi.client.drive.files.update({\n                fileId: googleDocId,\n                resource: {\n                    properties: {\n                        lastUpdated: new Date().toISOString()\n                    }\n                }\n            });\n        } catch (error) {\n            console.error(\"Error updating Google Doc: \".concat(error));\n            throw new Error(\"Failed to update Google Doc: \".concat(error));\n        }\n    }\n    /**\n   * Export a Google Doc to a specific format (PDF, DOCX)\n   * @param googleDocId The ID of the Google Doc to export\n   * @param mimeType The mime type to export to (e.g., 'application/pdf')\n   * @returns A URL to download the exported file\n   */ async exportGoogleDoc(googleDocId, mimeType) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            const response = await fetch(\"https://www.googleapis.com/drive/v3/files/\".concat(googleDocId, \"/export?mimeType=\").concat(encodeURIComponent(mimeType)), {\n                headers: {\n                    Authorization: \"Bearer \".concat(this.accessToken)\n                }\n            });\n            if (!response.ok) {\n                throw new Error(\"Failed to export Google Doc: \".concat(response.statusText));\n            }\n            const blob = await response.blob();\n            return URL.createObjectURL(blob);\n        } catch (error) {\n            console.error(\"Error exporting Google Doc: \".concat(error));\n            throw new Error(\"Failed to export Google Doc: \".concat(error));\n        }\n    }\n    /**\n   * Watch for changes to a Google Doc\n   * This is a placeholder for real-time sync functionality.\n   * In a production environment, you would use the Google Drive API's\n   * watch method or establish a WebSocket connection.\n   * \n   * @param googleDocId The ID of the Google Doc to watch\n   * @param callback The callback to call when the Google Doc changes\n   * @returns A function to stop watching for changes\n   */ watchGoogleDoc(googleDocId, callback) {\n        // This is a placeholder. In a real implementation, you would use the Google Drive API's\n        // changes.watch method or establish a WebSocket connection.\n        const checkInterval = 5000; // Check every 5 seconds\n        let lastModified = null;\n        const intervalId = setInterval(async ()=>{\n            try {\n                if (!this.isAuthenticated()) {\n                    console.warn(\"Not authenticated with Google Drive\");\n                    return;\n                }\n                const doc = await this.getGoogleDoc(googleDocId);\n                if (lastModified !== null && doc.modifiedTime !== lastModified) {\n                    // Document has changed\n                    callback({\n                        documentId: googleDocId,\n                        modifiedTime: doc.modifiedTime\n                    });\n                }\n                lastModified = doc.modifiedTime;\n            } catch (error) {\n                console.error(\"Error checking for Google Doc changes: \".concat(error));\n            }\n        }, checkInterval);\n        // Return a function to stop watching for changes\n        return ()=>clearInterval(intervalId);\n    }\n    /**\n   * Import a file from Google Drive\n   * @param fileId The ID of the file to import\n   * @returns The imported file data\n   */ async importFile(fileId) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            // Get file metadata\n            const metadataResponse = await window.gapi.client.drive.files.get({\n                fileId,\n                fields: \"name,mimeType\"\n            });\n            const { name, mimeType } = metadataResponse.result;\n            // Get file content\n            const contentResponse = await fetch(\"https://www.googleapis.com/drive/v3/files/\".concat(fileId, \"?alt=media\"), {\n                headers: {\n                    Authorization: \"Bearer \".concat(this.accessToken)\n                }\n            });\n            if (!contentResponse.ok) {\n                throw new Error(\"Failed to get file content: \".concat(contentResponse.statusText));\n            }\n            let content = \"\";\n            if (mimeType === \"application/vnd.google-apps.document\") {\n                // Export Google Doc to text\n                const exportUrl = await this.exportGoogleDoc(fileId, \"text/plain\");\n                const exportResponse = await fetch(exportUrl);\n                content = await exportResponse.text();\n            } else {\n                // Get raw content for other file types\n                content = await contentResponse.text();\n            }\n            return {\n                name,\n                content,\n                mimeType\n            };\n        } catch (error) {\n            console.error(\"Error importing file: \".concat(error));\n            throw new Error(\"Failed to import file: \".concat(error));\n        }\n    }\n    /**\n   * List files from Google Drive\n   * @param query Optional search query to filter files\n   * @returns Array of Google Drive files\n   */ async listDriveFiles() {\n        let query = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            const response = await window.gapi.client.drive.files.list({\n                pageSize: 30,\n                fields: \"files(id, name, mimeType, modifiedTime)\",\n                q: query ? \"name contains '\".concat(query, \"' and trashed = false\") : \"trashed = false\",\n                orderBy: \"modifiedTime desc\"\n            });\n            return response.result.files;\n        } catch (error) {\n            console.error(\"Error listing Drive files:\", error);\n            throw error;\n        }\n    }\n    constructor(config = {}){\n        this.gapiLoaded = false;\n        this.gisLoaded = false;\n        this.tokenClient = null;\n        this.accessToken = null;\n        this.config = {\n            ...DEFAULT_CONFIG,\n            ...config\n        };\n    }\n}\n/**\n * AI Conflict Detection Service\n * \n * This service implements a basic AI conflict detection algorithm\n * to flag conflicts between documents or content sections.\n * \n * In a production environment, this would integrate with an\n * actual NLP or AI service.\n */ class ConflictDetectionService {\n    /**\n   * Detect conflicts between document content sections\n   * @param contentA First content section\n   * @param contentB Second content section\n   * @returns Array of detected conflicts\n   */ detectConflicts(contentA, contentB) {\n        const conflicts = [];\n        // This is a very basic implementation for demonstration purposes\n        // Check for duplicate content (exact matches)\n        const paragraphsA = contentA.split(\"\\n\\n\");\n        const paragraphsB = contentB.split(\"\\n\\n\");\n        // Compare paragraphs for exact matches (simulating duplicate content detection)\n        for (const paraA of paragraphsA){\n            if (paraA.length > 50 && paragraphsB.includes(paraA)) {\n                conflicts.push({\n                    type: \"duplicate_content\",\n                    description: \"Duplicate paragraph detected\",\n                    sections: [\n                        paraA\n                    ]\n                });\n            }\n        }\n        // Simulating conflicting perspective detection\n        // In a real implementation, this would use NLP to detect contradictory statements\n        const keywordsA = this.extractKeywords(contentA);\n        const keywordsB = this.extractKeywords(contentB);\n        // Check for opposite sentiment keywords (very simplified approach)\n        const oppositeKeywords = [\n            [\n                \"support\",\n                \"oppose\"\n            ],\n            [\n                \"agree\",\n                \"disagree\"\n            ],\n            [\n                \"approve\",\n                \"disapprove\"\n            ],\n            [\n                \"increase\",\n                \"decrease\"\n            ],\n            [\n                \"positive\",\n                \"negative\"\n            ]\n        ];\n        for (const [positive, negative] of oppositeKeywords){\n            if (keywordsA.includes(positive) && keywordsB.includes(negative) || keywordsA.includes(negative) && keywordsB.includes(positive)) {\n                conflicts.push({\n                    type: \"conflicting_perspective\",\n                    description: 'Potentially conflicting positions: \"'.concat(positive, '\" vs \"').concat(negative, '\"'),\n                    sections: this.findSentencesWithKeywords([\n                        contentA,\n                        contentB\n                    ], [\n                        positive,\n                        negative\n                    ])\n                });\n            }\n        }\n        return conflicts;\n    }\n    /**\n   * Extract keywords from text (simplified implementation)\n   * @param text The text to extract keywords from\n   * @returns Array of extracted keywords\n   */ extractKeywords(text) {\n        // This is a simplified implementation.\n        // In a real app, you would use a proper NLP library for keyword extraction.\n        const words = text.toLowerCase().split(/\\W+/);\n        return Array.from(new Set(words.filter((word)=>word.length > 3)));\n    }\n    /**\n   * Find sentences containing specific keywords\n   * @param texts Array of text blocks to search in\n   * @param keywords Keywords to search for\n   * @returns Array of sentences containing the keywords\n   */ findSentencesWithKeywords(texts, keywords) {\n        const sentences = [];\n        // Split texts into sentences and find those containing keywords\n        for (const text of texts){\n            const textSentences = text.split(/[.!?]+/).filter((s)=>s.trim().length > 0);\n            for (const sentence of textSentences){\n                for (const keyword of keywords){\n                    if (sentence.toLowerCase().includes(keyword.toLowerCase())) {\n                        sentences.push(sentence.trim());\n                        break;\n                    }\n                }\n            }\n        }\n        return sentences;\n    }\n}\n// Create singleton instances for use throughout the application\nconst googleDriveService = new GoogleDriveService();\nconst conflictDetectionService = new ConflictDetectionService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TixTQUFVO29CQUM5QixJQUFJSyxTQUFTWixXQUFXLEdBQUdYLFFBQVEsQ0FBQ3dCLFFBQVFiLFdBQVcsS0FBSzt3QkFDMURRLFVBQVVsQixJQUFJLENBQUNzQixTQUFTRCxJQUFJO3dCQUM1QjtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxPQUFPSDtJQUNUO0FBQ0Y7QUFFQSxnRUFBZ0U7QUFDekQsTUFBTU0scUJBQXFCLElBQUlqSixxQkFBcUI7QUFDcEQsTUFBTWtKLDJCQUEyQixJQUFJcEMsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9nb29nbGVEcml2ZS50cz81NzVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR29vZ2xlIERyaXZlIEFQSSBJbnRlZ3JhdGlvbiBTZXJ2aWNlXG4gKiBcbiAqIFRoaXMgc2VydmljZSBoYW5kbGVzIHRoZSBpbnRlZ3JhdGlvbiB3aXRoIEdvb2dsZSBEcml2ZSBBUEkgZm9yIGRvY3VtZW50IG1hbmFnZW1lbnRcbiAqIGFuZCByZWFsLXRpbWUgY29sbGFib3JhdGlvbi5cbiAqIFxuICogR29vZ2xlIENsb3VkIFByb2plY3QgU2V0dXAgSW5zdHJ1Y3Rpb25zOlxuICogMS4gQ3JlYXRlIGEgbmV3IHByb2plY3QgaW4gR29vZ2xlIENsb3VkIENvbnNvbGUgKGh0dHBzOi8vY29uc29sZS5jbG91ZC5nb29nbGUuY29tLylcbiAqIDIuIEVuYWJsZSB0aGUgR29vZ2xlIERyaXZlIEFQSVxuICogMy4gQ29uZmlndXJlIE9BdXRoIGNvbnNlbnQgc2NyZWVuXG4gKiAgICAtIFVzZXIgVHlwZTogRXh0ZXJuYWxcbiAqICAgIC0gQXBwbGljYXRpb24gbmFtZTogTVVOIENvbm5lY3RcbiAqICAgIC0gQXV0aG9yaXplZCBkb21haW5zOiB5b3VyLWRvbWFpbi5jb21cbiAqICAgIC0gRGV2ZWxvcGVyIGNvbnRhY3QgaW5mb3JtYXRpb246IHlvdXItZW1haWxAZXhhbXBsZS5jb21cbiAqIDQuIENyZWF0ZSBPQXV0aCAyLjAgY3JlZGVudGlhbHNcbiAqICAgIC0gQXBwbGljYXRpb24gdHlwZTogV2ViIGFwcGxpY2F0aW9uXG4gKiAgICAtIE5hbWU6IE1VTiBDb25uZWN0IFdlYiBDbGllbnRcbiAqICAgIC0gQXV0aG9yaXplZCBKYXZhU2NyaXB0IG9yaWdpbnM6IGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMCwgaHR0cHM6Ly95b3VyLWRvbWFpbi5jb21cbiAqICAgIC0gQXV0aG9yaXplZCByZWRpcmVjdCBVUklzOiBodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGgvY2FsbGJhY2svZ29vZ2xlLCBodHRwczovL3lvdXItZG9tYWluLmNvbS9hcGkvYXV0aC9jYWxsYmFjay9nb29nbGVcbiAqIDUuIEFkZCB0aGUgZm9sbG93aW5nIGVudmlyb25tZW50IHZhcmlhYmxlcyB0byB5b3VyIC5lbnYubG9jYWwgZmlsZTpcbiAqICAgIC0gR09PR0xFX0NMSUVOVF9JRD15b3VyLWNsaWVudC1pZFxuICogICAgLSBHT09HTEVfQ0xJRU5UX1NFQ1JFVD15b3VyLWNsaWVudC1zZWNyZXRcbiAqICAgIC0gR09PR0xFX0FQSV9LRVk9eW91ci1hcGkta2V5IChmb3IgcHVibGljIEFQSSBhY2Nlc3MpXG4gKi9cblxuaW1wb3J0IHsgRG9jdW1lbnQgfSBmcm9tICcuL2RvY3VtZW50JztcblxuLy8gQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBHb29nbGUgRHJpdmUgQVBJXG5pbnRlcmZhY2UgR29vZ2xlRHJpdmVDb25maWcge1xuICBjbGllbnRJZDogc3RyaW5nO1xuICBhcGlLZXk6IHN0cmluZztcbiAgc2NvcGVzOiBzdHJpbmdbXTtcbn1cblxuLy8gRGVmYXVsdCBjb25maWd1cmF0aW9uIC0gdGhlc2UgdmFsdWVzIHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIGVudmlyb25tZW50IHZhcmlhYmxlc1xuY29uc3QgREVGQVVMVF9DT05GSUc6IEdvb2dsZURyaXZlQ29uZmlnID0ge1xuICBjbGllbnRJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX0NMSUVOVF9JRCB8fCAnJyxcbiAgYXBpS2V5OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HT09HTEVfQVBJX0tFWSB8fCAnJyxcbiAgc2NvcGVzOiBbXG4gICAgJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZHJpdmUuZmlsZScsXG4gICAgJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZHJpdmUuYXBwZGF0YScsXG4gIF0sXG59O1xuXG4vLyBHb29nbGUgRHJpdmUgQVBJIFNlcnZpY2VcbmV4cG9ydCBjbGFzcyBHb29nbGVEcml2ZVNlcnZpY2Uge1xuICBwcml2YXRlIGdhcGlMb2FkZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBnaXNMb2FkZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSB0b2tlbkNsaWVudDogYW55ID0gbnVsbDtcbiAgcHJpdmF0ZSBhY2Nlc3NUb2tlbjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgY29uZmlnOiBHb29nbGVEcml2ZUNvbmZpZztcbiAgXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogUGFydGlhbDxHb29nbGVEcml2ZUNvbmZpZz4gPSB7fSkge1xuICAgIHRoaXMuY29uZmlnID0geyAuLi5ERUZBVUxUX0NPTkZJRywgLi4uY29uZmlnIH07XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBHb29nbGUgRHJpdmUgQVBJXG4gICAqIFRoaXMgbG9hZHMgdGhlIHJlcXVpcmVkIGxpYnJhcmllcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIEFQSSBjbGllbnRcbiAgICovXG4gIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIExvYWQgdGhlIEdvb2dsZSBBUEkgY2xpZW50IGxpYnJhcnlcbiAgICAgICAgY29uc3Qgc2NyaXB0MSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHQxLnNyYyA9ICdodHRwczovL2FwaXMuZ29vZ2xlLmNvbS9qcy9hcGkuanMnO1xuICAgICAgICBzY3JpcHQxLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmdhcGlMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMubG9hZEdhcGlDbGllbnQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdpc0xvYWRlZCkgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBzY3JpcHQxLm9uZXJyb3IgPSAoZXJyb3IpID0+IHJlamVjdChgRmFpbGVkIHRvIGxvYWQgR29vZ2xlIEFQSSBjbGllbnQ6ICR7ZXJyb3J9YCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0MSk7XG4gICAgICAgIFxuICAgICAgICAvLyBMb2FkIHRoZSBHb29nbGUgSWRlbnRpdHkgU2VydmljZXMgbGlicmFyeVxuICAgICAgICBjb25zdCBzY3JpcHQyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdDIuc3JjID0gJ2h0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbS9nc2kvY2xpZW50JztcbiAgICAgICAgc2NyaXB0Mi5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5naXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZVRva2VuQ2xpZW50KCk7XG4gICAgICAgICAgaWYgKHRoaXMuZ2FwaUxvYWRlZCkgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBzY3JpcHQyLm9uZXJyb3IgPSAoZXJyb3IpID0+IHJlamVjdChgRmFpbGVkIHRvIGxvYWQgR29vZ2xlIElkZW50aXR5IFNlcnZpY2VzOiAke2Vycm9yfWApO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdDIpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGBFcnJvciBpbml0aWFsaXppbmcgR29vZ2xlIERyaXZlIEFQSTogJHtlcnJvcn1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIExvYWQgdGhlIEdvb2dsZSBBUEkgY2xpZW50IGxpYnJhcnlcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgbG9hZEdhcGlDbGllbnQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdpbmRvdy5nYXBpLmxvYWQoJ2NsaWVudCcsIHtcbiAgICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgd2luZG93LmdhcGkuY2xpZW50LmluaXQoe1xuICAgICAgICAgICAgICAgIGFwaUtleTogdGhpcy5jb25maWcuYXBpS2V5LFxuICAgICAgICAgICAgICAgIGRpc2NvdmVyeURvY3M6IFsnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vZGlzY292ZXJ5L3YxL2FwaXMvZHJpdmUvdjMvcmVzdCddLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGBFcnJvciBpbml0aWFsaXppbmcgR0FQSSBjbGllbnQ6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbmVycm9yOiAoZXJyb3I6IGFueSkgPT4gcmVqZWN0KGBFcnJvciBsb2FkaW5nIEdBUEkgY2xpZW50OiAke2Vycm9yfWApLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChgRmFpbGVkIHRvIGxvYWQgR0FQSSBjbGllbnQ6ICR7ZXJyb3J9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBHb29nbGUgSWRlbnRpdHkgU2VydmljZXMgdG9rZW4gY2xpZW50XG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVUb2tlbkNsaWVudCgpOiB2b2lkIHtcbiAgICB0aGlzLnRva2VuQ2xpZW50ID0gd2luZG93Lmdvb2dsZS5hY2NvdW50cy5vYXV0aDIuaW5pdFRva2VuQ2xpZW50KHtcbiAgICAgIGNsaWVudF9pZDogdGhpcy5jb25maWcuY2xpZW50SWQsXG4gICAgICBzY29wZTogdGhpcy5jb25maWcuc2NvcGVzLmpvaW4oJyAnKSxcbiAgICAgIGNhbGxiYWNrOiAodG9rZW5SZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgIGlmICh0b2tlblJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2V0dGluZyBhY2Nlc3MgdG9rZW46ICR7dG9rZW5SZXNwb25zZS5lcnJvcn1gKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHRva2VuUmVzcG9uc2UuYWNjZXNzX3Rva2VuO1xuICAgICAgICB3aW5kb3cuZ2FwaS5jbGllbnQuc2V0VG9rZW4odG9rZW5SZXNwb25zZSk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogQXV0aGVudGljYXRlIHRoZSB1c2VyIGFuZCByZXF1ZXN0IGFjY2VzcyB0byBHb29nbGUgRHJpdmVcbiAgICovXG4gIGFzeW5jIGF1dGhlbnRpY2F0ZSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGlmICghdGhpcy50b2tlbkNsaWVudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUb2tlbiBjbGllbnQgbm90IGluaXRpYWxpemVkJyk7XG4gICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMudG9rZW5DbGllbnQuY2FsbGJhY2sgPSAocmVzcDogYW55KSA9PiB7XG4gICAgICAgICAgaWYgKHJlc3AuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGR1cmluZyBhdXRoZW50aWNhdGlvbjogJHtyZXNwLmVycm9yfWApO1xuICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSByZXNwLmFjY2Vzc190b2tlbjtcbiAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgaWYgKHdpbmRvdy5nYXBpLmNsaWVudC5nZXRUb2tlbigpID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gUmVxdWVzdCBhbiBhY2Nlc3MgdG9rZW5cbiAgICAgICAgICB0aGlzLnRva2VuQ2xpZW50LnJlcXVlc3RBY2Nlc3NUb2tlbih7IHByb21wdDogJ2NvbnNlbnQnIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFscmVhZHkgaGF2ZSBhbiBhY2Nlc3MgdG9rZW5cbiAgICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gd2luZG93LmdhcGkuY2xpZW50LmdldFRva2VuKCkuYWNjZXNzX3Rva2VuO1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGF1dGhlbnRpY2F0aW5nOiAke2Vycm9yfWApO1xuICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB1c2VyIGlzIGF1dGhlbnRpY2F0ZWRcbiAgICovXG4gIGlzQXV0aGVudGljYXRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hY2Nlc3NUb2tlbiAhPT0gbnVsbDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBHb29nbGUgRG9jIGZvciBhIGRvY3VtZW50XG4gICAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gY3JlYXRlIGEgR29vZ2xlIERvYyBmb3JcbiAgICogQHJldHVybnMgVGhlIElEIG9mIHRoZSBjcmVhdGVkIEdvb2dsZSBEb2NcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUdvb2dsZURvYyhkb2N1bWVudDogRG9jdW1lbnQpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICghdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCB3aXRoIEdvb2dsZSBEcml2ZScpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cuZ2FwaS5jbGllbnQuZHJpdmUuZmlsZXMuY3JlYXRlKHtcbiAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICBuYW1lOiBkb2N1bWVudC50aXRsZSxcbiAgICAgICAgICBtaW1lVHlwZTogJ2FwcGxpY2F0aW9uL3ZuZC5nb29nbGUtYXBwcy5kb2N1bWVudCcsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBNVU4gQ29ubmVjdCBkb2N1bWVudDogJHtkb2N1bWVudC50eXBlfSBmb3IgJHtkb2N1bWVudC5jb21taXR0ZWV9IC0gJHtkb2N1bWVudC5jb3VudHJ5fWAsXG4gICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgbXVuQ29ubmVjdERvY0lkOiBkb2N1bWVudC5pZCxcbiAgICAgICAgICAgIGRvY3VtZW50VHlwZTogZG9jdW1lbnQudHlwZSxcbiAgICAgICAgICAgIGNvbW1pdHRlZTogZG9jdW1lbnQuY29tbWl0dGVlLFxuICAgICAgICAgICAgY291bnRyeTogZG9jdW1lbnQuY291bnRyeSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBmaWVsZHM6ICdpZCx3ZWJWaWV3TGluaycsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdC5pZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY3JlYXRpbmcgR29vZ2xlIERvYzogJHtlcnJvcn1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBHb29nbGUgRG9jOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBhIEdvb2dsZSBEb2MgYnkgaXRzIElEXG4gICAqIEBwYXJhbSBnb29nbGVEb2NJZCBUaGUgSUQgb2YgdGhlIEdvb2dsZSBEb2MgdG8gZ2V0XG4gICAqIEByZXR1cm5zIFRoZSBHb29nbGUgRG9jIG1ldGFkYXRhXG4gICAqL1xuICBhc3luYyBnZXRHb29nbGVEb2MoZ29vZ2xlRG9jSWQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCF0aGlzLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRoZW50aWNhdGVkIHdpdGggR29vZ2xlIERyaXZlJyk7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5nYXBpLmNsaWVudC5kcml2ZS5maWxlcy5nZXQoe1xuICAgICAgICBmaWxlSWQ6IGdvb2dsZURvY0lkLFxuICAgICAgICBmaWVsZHM6ICdpZCxuYW1lLHdlYlZpZXdMaW5rLG1vZGlmaWVkVGltZSxjYXBhYmlsaXRpZXMnLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGdldHRpbmcgR29vZ2xlIERvYzogJHtlcnJvcn1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBHb29nbGUgRG9jOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFVwZGF0ZSBhIEdvb2dsZSBEb2MncyBjb250ZW50XG4gICAqIEBwYXJhbSBnb29nbGVEb2NJZCBUaGUgSUQgb2YgdGhlIEdvb2dsZSBEb2MgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSBjb250ZW50IFRoZSBuZXcgY29udGVudCBvZiB0aGUgR29vZ2xlIERvY1xuICAgKi9cbiAgYXN5bmMgdXBkYXRlR29vZ2xlRG9jKGdvb2dsZURvY0lkOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCB3aXRoIEdvb2dsZSBEcml2ZScpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgdmVyc2lvbi4gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLFxuICAgICAgLy8geW91IHdvdWxkIHVzZSB0aGUgR29vZ2xlIERvY3MgQVBJIHRvIHVwZGF0ZSB0aGUgZG9jdW1lbnQgY29udGVudC5cbiAgICAgIC8vIEZvciBzaW1wbGljaXR5LCB3ZSdyZSBqdXN0IHVwZGF0aW5nIHRoZSBkb2N1bWVudCdzIG1ldGFkYXRhIGhlcmUuXG4gICAgICBhd2FpdCB3aW5kb3cuZ2FwaS5jbGllbnQuZHJpdmUuZmlsZXMudXBkYXRlKHtcbiAgICAgICAgZmlsZUlkOiBnb29nbGVEb2NJZCxcbiAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgdXBkYXRpbmcgR29vZ2xlIERvYzogJHtlcnJvcn1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSBHb29nbGUgRG9jOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEV4cG9ydCBhIEdvb2dsZSBEb2MgdG8gYSBzcGVjaWZpYyBmb3JtYXQgKFBERiwgRE9DWClcbiAgICogQHBhcmFtIGdvb2dsZURvY0lkIFRoZSBJRCBvZiB0aGUgR29vZ2xlIERvYyB0byBleHBvcnRcbiAgICogQHBhcmFtIG1pbWVUeXBlIFRoZSBtaW1lIHR5cGUgdG8gZXhwb3J0IHRvIChlLmcuLCAnYXBwbGljYXRpb24vcGRmJylcbiAgICogQHJldHVybnMgQSBVUkwgdG8gZG93bmxvYWQgdGhlIGV4cG9ydGVkIGZpbGVcbiAgICovXG4gIGFzeW5jIGV4cG9ydEdvb2dsZURvYyhnb29nbGVEb2NJZDogc3RyaW5nLCBtaW1lVHlwZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuaXNBdXRoZW50aWNhdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhlbnRpY2F0ZWQgd2l0aCBHb29nbGUgRHJpdmUnKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgIGBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9kcml2ZS92My9maWxlcy8ke2dvb2dsZURvY0lkfS9leHBvcnQ/bWltZVR5cGU9JHtlbmNvZGVVUklDb21wb25lbnQobWltZVR5cGUpfWAsXG4gICAgICAgIHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5hY2Nlc3NUb2tlbn1gLFxuICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZXhwb3J0IEdvb2dsZSBEb2M6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBleHBvcnRpbmcgR29vZ2xlIERvYzogJHtlcnJvcn1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGV4cG9ydCBHb29nbGUgRG9jOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFdhdGNoIGZvciBjaGFuZ2VzIHRvIGEgR29vZ2xlIERvY1xuICAgKiBUaGlzIGlzIGEgcGxhY2Vob2xkZXIgZm9yIHJlYWwtdGltZSBzeW5jIGZ1bmN0aW9uYWxpdHkuXG4gICAqIEluIGEgcHJvZHVjdGlvbiBlbnZpcm9ubWVudCwgeW91IHdvdWxkIHVzZSB0aGUgR29vZ2xlIERyaXZlIEFQSSdzXG4gICAqIHdhdGNoIG1ldGhvZCBvciBlc3RhYmxpc2ggYSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgICogXG4gICAqIEBwYXJhbSBnb29nbGVEb2NJZCBUaGUgSUQgb2YgdGhlIEdvb2dsZSBEb2MgdG8gd2F0Y2hcbiAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gdGhlIEdvb2dsZSBEb2MgY2hhbmdlc1xuICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRvIHN0b3Agd2F0Y2hpbmcgZm9yIGNoYW5nZXNcbiAgICovXG4gIHdhdGNoR29vZ2xlRG9jKGdvb2dsZURvY0lkOiBzdHJpbmcsIGNhbGxiYWNrOiAoY2hhbmdlczogYW55KSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gICAgLy8gVGhpcyBpcyBhIHBsYWNlaG9sZGVyLiBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHlvdSB3b3VsZCB1c2UgdGhlIEdvb2dsZSBEcml2ZSBBUEknc1xuICAgIC8vIGNoYW5nZXMud2F0Y2ggbWV0aG9kIG9yIGVzdGFibGlzaCBhIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgIGNvbnN0IGNoZWNrSW50ZXJ2YWwgPSA1MDAwOyAvLyBDaGVjayBldmVyeSA1IHNlY29uZHNcbiAgICBsZXQgbGFzdE1vZGlmaWVkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICBcbiAgICBjb25zdCBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdOb3QgYXV0aGVudGljYXRlZCB3aXRoIEdvb2dsZSBEcml2ZScpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgZG9jID0gYXdhaXQgdGhpcy5nZXRHb29nbGVEb2MoZ29vZ2xlRG9jSWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGxhc3RNb2RpZmllZCAhPT0gbnVsbCAmJiBkb2MubW9kaWZpZWRUaW1lICE9PSBsYXN0TW9kaWZpZWQpIHtcbiAgICAgICAgICAvLyBEb2N1bWVudCBoYXMgY2hhbmdlZFxuICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgIGRvY3VtZW50SWQ6IGdvb2dsZURvY0lkLFxuICAgICAgICAgICAgbW9kaWZpZWRUaW1lOiBkb2MubW9kaWZpZWRUaW1lLFxuICAgICAgICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB5b3Ugd291bGQgaW5jbHVkZSB0aGUgYWN0dWFsIGNoYW5nZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbGFzdE1vZGlmaWVkID0gZG9jLm1vZGlmaWVkVGltZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNoZWNraW5nIGZvciBHb29nbGUgRG9jIGNoYW5nZXM6ICR7ZXJyb3J9YCk7XG4gICAgICB9XG4gICAgfSwgY2hlY2tJbnRlcnZhbCk7XG4gICAgXG4gICAgLy8gUmV0dXJuIGEgZnVuY3Rpb24gdG8gc3RvcCB3YXRjaGluZyBmb3IgY2hhbmdlc1xuICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICB9XG4gIFxuICAvKipcbiAgICogSW1wb3J0IGEgZmlsZSBmcm9tIEdvb2dsZSBEcml2ZVxuICAgKiBAcGFyYW0gZmlsZUlkIFRoZSBJRCBvZiB0aGUgZmlsZSB0byBpbXBvcnRcbiAgICogQHJldHVybnMgVGhlIGltcG9ydGVkIGZpbGUgZGF0YVxuICAgKi9cbiAgYXN5bmMgaW1wb3J0RmlsZShmaWxlSWQ6IHN0cmluZyk6IFByb21pc2U8eyBuYW1lOiBzdHJpbmc7IGNvbnRlbnQ6IHN0cmluZzsgbWltZVR5cGU6IHN0cmluZyB9PiB7XG4gICAgaWYgKCF0aGlzLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRoZW50aWNhdGVkIHdpdGggR29vZ2xlIERyaXZlJyk7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgZmlsZSBtZXRhZGF0YVxuICAgICAgY29uc3QgbWV0YWRhdGFSZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5nYXBpLmNsaWVudC5kcml2ZS5maWxlcy5nZXQoe1xuICAgICAgICBmaWxlSWQsXG4gICAgICAgIGZpZWxkczogJ25hbWUsbWltZVR5cGUnLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgbmFtZSwgbWltZVR5cGUgfSA9IG1ldGFkYXRhUmVzcG9uc2UucmVzdWx0O1xuICAgICAgXG4gICAgICAvLyBHZXQgZmlsZSBjb250ZW50XG4gICAgICBjb25zdCBjb250ZW50UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2RyaXZlL3YzL2ZpbGVzLyR7ZmlsZUlkfT9hbHQ9bWVkaWFgLFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuYWNjZXNzVG9rZW59YCxcbiAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAoIWNvbnRlbnRSZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgZmlsZSBjb250ZW50OiAke2NvbnRlbnRSZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBsZXQgY29udGVudCA9ICcnO1xuICAgICAgXG4gICAgICBpZiAobWltZVR5cGUgPT09ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWFwcHMuZG9jdW1lbnQnKSB7XG4gICAgICAgIC8vIEV4cG9ydCBHb29nbGUgRG9jIHRvIHRleHRcbiAgICAgICAgY29uc3QgZXhwb3J0VXJsID0gYXdhaXQgdGhpcy5leHBvcnRHb29nbGVEb2MoZmlsZUlkLCAndGV4dC9wbGFpbicpO1xuICAgICAgICBjb25zdCBleHBvcnRSZXNwb25zZSA9IGF3YWl0IGZldGNoKGV4cG9ydFVybCk7XG4gICAgICAgIGNvbnRlbnQgPSBhd2FpdCBleHBvcnRSZXNwb25zZS50ZXh0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHZXQgcmF3IGNvbnRlbnQgZm9yIG90aGVyIGZpbGUgdHlwZXNcbiAgICAgICAgY29udGVudCA9IGF3YWl0IGNvbnRlbnRSZXNwb25zZS50ZXh0KCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7IG5hbWUsIGNvbnRlbnQsIG1pbWVUeXBlIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGltcG9ydGluZyBmaWxlOiAke2Vycm9yfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gaW1wb3J0IGZpbGU6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgZmlsZXMgZnJvbSBHb29nbGUgRHJpdmVcbiAgICogQHBhcmFtIHF1ZXJ5IE9wdGlvbmFsIHNlYXJjaCBxdWVyeSB0byBmaWx0ZXIgZmlsZXNcbiAgICogQHJldHVybnMgQXJyYXkgb2YgR29vZ2xlIERyaXZlIGZpbGVzXG4gICAqL1xuICBhc3luYyBsaXN0RHJpdmVGaWxlcyhxdWVyeTogc3RyaW5nID0gJycpIHtcbiAgICBpZiAoIXRoaXMuaXNBdXRoZW50aWNhdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhlbnRpY2F0ZWQgd2l0aCBHb29nbGUgRHJpdmUnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cuZ2FwaS5jbGllbnQuZHJpdmUuZmlsZXMubGlzdCh7XG4gICAgICAgIHBhZ2VTaXplOiAzMCxcbiAgICAgICAgZmllbGRzOiAnZmlsZXMoaWQsIG5hbWUsIG1pbWVUeXBlLCBtb2RpZmllZFRpbWUpJyxcbiAgICAgICAgcTogcXVlcnkgPyBgbmFtZSBjb250YWlucyAnJHtxdWVyeX0nIGFuZCB0cmFzaGVkID0gZmFsc2VgIDogJ3RyYXNoZWQgPSBmYWxzZScsXG4gICAgICAgIG9yZGVyQnk6ICdtb2RpZmllZFRpbWUgZGVzYydcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0LmZpbGVzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsaXN0aW5nIERyaXZlIGZpbGVzOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFJIENvbmZsaWN0IERldGVjdGlvbiBTZXJ2aWNlXG4gKiBcbiAqIFRoaXMgc2VydmljZSBpbXBsZW1lbnRzIGEgYmFzaWMgQUkgY29uZmxpY3QgZGV0ZWN0aW9uIGFsZ29yaXRobVxuICogdG8gZmxhZyBjb25mbGljdHMgYmV0d2VlbiBkb2N1bWVudHMgb3IgY29udGVudCBzZWN0aW9ucy5cbiAqIFxuICogSW4gYSBwcm9kdWN0aW9uIGVudmlyb25tZW50LCB0aGlzIHdvdWxkIGludGVncmF0ZSB3aXRoIGFuXG4gKiBhY3R1YWwgTkxQIG9yIEFJIHNlcnZpY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25mbGljdERldGVjdGlvblNlcnZpY2Uge1xuICAvKipcbiAgICogRGV0ZWN0IGNvbmZsaWN0cyBiZXR3ZWVuIGRvY3VtZW50IGNvbnRlbnQgc2VjdGlvbnNcbiAgICogQHBhcmFtIGNvbnRlbnRBIEZpcnN0IGNvbnRlbnQgc2VjdGlvblxuICAgKiBAcGFyYW0gY29udGVudEIgU2Vjb25kIGNvbnRlbnQgc2VjdGlvblxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBkZXRlY3RlZCBjb25mbGljdHNcbiAgICovXG4gIGRldGVjdENvbmZsaWN0cyhjb250ZW50QTogc3RyaW5nLCBjb250ZW50Qjogc3RyaW5nKTogQXJyYXk8e1xuICAgIHR5cGU6ICdkdXBsaWNhdGVfY29udGVudCcgfCAnY29uZmxpY3RpbmdfcGVyc3BlY3RpdmUnO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgc2VjdGlvbnM6IHN0cmluZ1tdO1xuICB9PiB7XG4gICAgY29uc3QgY29uZmxpY3RzOiBBcnJheTx7XG4gICAgICB0eXBlOiAnZHVwbGljYXRlX2NvbnRlbnQnIHwgJ2NvbmZsaWN0aW5nX3BlcnNwZWN0aXZlJztcbiAgICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgICBzZWN0aW9uczogc3RyaW5nW107XG4gICAgfT4gPSBbXTtcbiAgICBcbiAgICAvLyBUaGlzIGlzIGEgdmVyeSBiYXNpYyBpbXBsZW1lbnRhdGlvbiBmb3IgZGVtb25zdHJhdGlvbiBwdXJwb3Nlc1xuICAgIFxuICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgY29udGVudCAoZXhhY3QgbWF0Y2hlcylcbiAgICBjb25zdCBwYXJhZ3JhcGhzQSA9IGNvbnRlbnRBLnNwbGl0KCdcXG5cXG4nKTtcbiAgICBjb25zdCBwYXJhZ3JhcGhzQiA9IGNvbnRlbnRCLnNwbGl0KCdcXG5cXG4nKTtcbiAgICBcbiAgICAvLyBDb21wYXJlIHBhcmFncmFwaHMgZm9yIGV4YWN0IG1hdGNoZXMgKHNpbXVsYXRpbmcgZHVwbGljYXRlIGNvbnRlbnQgZGV0ZWN0aW9uKVxuICAgIGZvciAoY29uc3QgcGFyYUEgb2YgcGFyYWdyYXBoc0EpIHtcbiAgICAgIGlmIChwYXJhQS5sZW5ndGggPiA1MCAmJiBwYXJhZ3JhcGhzQi5pbmNsdWRlcyhwYXJhQSkpIHtcbiAgICAgICAgY29uZmxpY3RzLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdkdXBsaWNhdGVfY29udGVudCcsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdEdXBsaWNhdGUgcGFyYWdyYXBoIGRldGVjdGVkJyxcbiAgICAgICAgICBzZWN0aW9uczogW3BhcmFBXSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFNpbXVsYXRpbmcgY29uZmxpY3RpbmcgcGVyc3BlY3RpdmUgZGV0ZWN0aW9uXG4gICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIHVzZSBOTFAgdG8gZGV0ZWN0IGNvbnRyYWRpY3Rvcnkgc3RhdGVtZW50c1xuICAgIGNvbnN0IGtleXdvcmRzQSA9IHRoaXMuZXh0cmFjdEtleXdvcmRzKGNvbnRlbnRBKTtcbiAgICBjb25zdCBrZXl3b3Jkc0IgPSB0aGlzLmV4dHJhY3RLZXl3b3Jkcyhjb250ZW50Qik7XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIG9wcG9zaXRlIHNlbnRpbWVudCBrZXl3b3JkcyAodmVyeSBzaW1wbGlmaWVkIGFwcHJvYWNoKVxuICAgIGNvbnN0IG9wcG9zaXRlS2V5d29yZHMgPSBbXG4gICAgICBbJ3N1cHBvcnQnLCAnb3Bwb3NlJ10sXG4gICAgICBbJ2FncmVlJywgJ2Rpc2FncmVlJ10sXG4gICAgICBbJ2FwcHJvdmUnLCAnZGlzYXBwcm92ZSddLFxuICAgICAgWydpbmNyZWFzZScsICdkZWNyZWFzZSddLFxuICAgICAgWydwb3NpdGl2ZScsICduZWdhdGl2ZSddLFxuICAgIF07XG4gICAgXG4gICAgZm9yIChjb25zdCBbcG9zaXRpdmUsIG5lZ2F0aXZlXSBvZiBvcHBvc2l0ZUtleXdvcmRzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChrZXl3b3Jkc0EuaW5jbHVkZXMocG9zaXRpdmUpICYmIGtleXdvcmRzQi5pbmNsdWRlcyhuZWdhdGl2ZSkpIHx8XG4gICAgICAgIChrZXl3b3Jkc0EuaW5jbHVkZXMobmVnYXRpdmUpICYmIGtleXdvcmRzQi5pbmNsdWRlcyhwb3NpdGl2ZSkpXG4gICAgICApIHtcbiAgICAgICAgY29uZmxpY3RzLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdjb25mbGljdGluZ19wZXJzcGVjdGl2ZScsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBQb3RlbnRpYWxseSBjb25mbGljdGluZyBwb3NpdGlvbnM6IFwiJHtwb3NpdGl2ZX1cIiB2cyBcIiR7bmVnYXRpdmV9XCJgLFxuICAgICAgICAgIHNlY3Rpb25zOiB0aGlzLmZpbmRTZW50ZW5jZXNXaXRoS2V5d29yZHMoXG4gICAgICAgICAgICBbY29udGVudEEsIGNvbnRlbnRCXSxcbiAgICAgICAgICAgIFtwb3NpdGl2ZSwgbmVnYXRpdmVdXG4gICAgICAgICAgKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjb25mbGljdHM7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBFeHRyYWN0IGtleXdvcmRzIGZyb20gdGV4dCAoc2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbilcbiAgICogQHBhcmFtIHRleHQgVGhlIHRleHQgdG8gZXh0cmFjdCBrZXl3b3JkcyBmcm9tXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGV4dHJhY3RlZCBrZXl3b3Jkc1xuICAgKi9cbiAgcHJpdmF0ZSBleHRyYWN0S2V5d29yZHModGV4dDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uLlxuICAgIC8vIEluIGEgcmVhbCBhcHAsIHlvdSB3b3VsZCB1c2UgYSBwcm9wZXIgTkxQIGxpYnJhcnkgZm9yIGtleXdvcmQgZXh0cmFjdGlvbi5cbiAgICBjb25zdCB3b3JkcyA9IHRleHQudG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxXKy8pO1xuICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQod29yZHMuZmlsdGVyKHdvcmQgPT4gd29yZC5sZW5ndGggPiAzKSkpO1xuICB9XG4gIFxuICAvKipcbiAgICogRmluZCBzZW50ZW5jZXMgY29udGFpbmluZyBzcGVjaWZpYyBrZXl3b3Jkc1xuICAgKiBAcGFyYW0gdGV4dHMgQXJyYXkgb2YgdGV4dCBibG9ja3MgdG8gc2VhcmNoIGluXG4gICAqIEBwYXJhbSBrZXl3b3JkcyBLZXl3b3JkcyB0byBzZWFyY2ggZm9yXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIHNlbnRlbmNlcyBjb250YWluaW5nIHRoZSBrZXl3b3Jkc1xuICAgKi9cbiAgcHJpdmF0ZSBmaW5kU2VudGVuY2VzV2l0aEtleXdvcmRzKHRleHRzOiBzdHJpbmdbXSwga2V5d29yZHM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHNlbnRlbmNlczogc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICAvLyBTcGxpdCB0ZXh0cyBpbnRvIHNlbnRlbmNlcyBhbmQgZmluZCB0aG9zZSBjb250YWluaW5nIGtleXdvcmRzXG4gICAgZm9yIChjb25zdCB0ZXh0IG9mIHRleHRzKSB7XG4gICAgICBjb25zdCB0ZXh0U2VudGVuY2VzID0gdGV4dC5zcGxpdCgvWy4hP10rLykuZmlsdGVyKHMgPT4gcy50cmltKCkubGVuZ3RoID4gMCk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3Qgc2VudGVuY2Ugb2YgdGV4dFNlbnRlbmNlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleXdvcmQgb2Yga2V5d29yZHMpIHtcbiAgICAgICAgICBpZiAoc2VudGVuY2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhrZXl3b3JkLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICBzZW50ZW5jZXMucHVzaChzZW50ZW5jZS50cmltKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzZW50ZW5jZXM7XG4gIH1cbn1cblxuLy8gQ3JlYXRlIHNpbmdsZXRvbiBpbnN0YW5jZXMgZm9yIHVzZSB0aHJvdWdob3V0IHRoZSBhcHBsaWNhdGlvblxuZXhwb3J0IGNvbnN0IGdvb2dsZURyaXZlU2VydmljZSA9IG5ldyBHb29nbGVEcml2ZVNlcnZpY2UoKTtcbmV4cG9ydCBjb25zdCBjb25mbGljdERldGVjdGlvblNlcnZpY2UgPSBuZXcgQ29uZmxpY3REZXRlY3Rpb25TZXJ2aWNlKCk7XG5cbi8vIEFkZCBUeXBlU2NyaXB0IGludGVyZmFjZXMgZm9yIEdvb2dsZSBBUEkgd2luZG93cyByZWZlcmVuY2VzXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIGdhcGk6IGFueTtcbiAgICBnb29nbGU6IGFueTtcbiAgfVxufSAiXSwibmFtZXMiOlsiREVGQVVMVF9DT05GSUciLCJjbGllbnRJZCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19HT09HTEVfQ0xJRU5UX0lEIiwiYXBpS2V5IiwiTkVYVF9QVUJMSUNfR09PR0xFX0FQSV9LRVkiLCJzY29wZXMiLCJHb29nbGVEcml2ZVNlcnZpY2UiLCJpbml0aWFsaXplIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzY3JpcHQxIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwib25sb2FkIiwiZ2FwaUxvYWRlZCIsImxvYWRHYXBpQ2xpZW50IiwidGhlbiIsImdpc0xvYWRlZCIsIm9uZXJyb3IiLCJlcnJvciIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInNjcmlwdDIiLCJpbml0aWFsaXplVG9rZW5DbGllbnQiLCJ3aW5kb3ciLCJnYXBpIiwibG9hZCIsImNhbGxiYWNrIiwiY2xpZW50IiwiaW5pdCIsImNvbmZpZyIsImRpc2NvdmVyeURvY3MiLCJ0b2tlbkNsaWVudCIsImdvb2dsZSIsImFjY291bnRzIiwib2F1dGgyIiwiaW5pdFRva2VuQ2xpZW50IiwiY2xpZW50X2lkIiwic2NvcGUiLCJqb2luIiwidG9rZW5SZXNwb25zZSIsImNvbnNvbGUiLCJhY2Nlc3NUb2tlbiIsImFjY2Vzc190b2tlbiIsInNldFRva2VuIiwiYXV0aGVudGljYXRlIiwicmVzcCIsImdldFRva2VuIiwicmVxdWVzdEFjY2Vzc1Rva2VuIiwicHJvbXB0IiwiaXNBdXRoZW50aWNhdGVkIiwiY3JlYXRlR29vZ2xlRG9jIiwiRXJyb3IiLCJyZXNwb25zZSIsImRyaXZlIiwiZmlsZXMiLCJjcmVhdGUiLCJyZXNvdXJjZSIsIm5hbWUiLCJ0aXRsZSIsIm1pbWVUeXBlIiwiZGVzY3JpcHRpb24iLCJ0eXBlIiwiY29tbWl0dGVlIiwiY291bnRyeSIsInByb3BlcnRpZXMiLCJtdW5Db25uZWN0RG9jSWQiLCJpZCIsImRvY3VtZW50VHlwZSIsImZpZWxkcyIsInJlc3VsdCIsImdldEdvb2dsZURvYyIsImdvb2dsZURvY0lkIiwiZ2V0IiwiZmlsZUlkIiwidXBkYXRlR29vZ2xlRG9jIiwiY29udGVudCIsInVwZGF0ZSIsImxhc3RVcGRhdGVkIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiZXhwb3J0R29vZ2xlRG9jIiwiZmV0Y2giLCJlbmNvZGVVUklDb21wb25lbnQiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsIm9rIiwic3RhdHVzVGV4dCIsImJsb2IiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJ3YXRjaEdvb2dsZURvYyIsImNoZWNrSW50ZXJ2YWwiLCJsYXN0TW9kaWZpZWQiLCJpbnRlcnZhbElkIiwic2V0SW50ZXJ2YWwiLCJ3YXJuIiwiZG9jIiwibW9kaWZpZWRUaW1lIiwiZG9jdW1lbnRJZCIsImNsZWFySW50ZXJ2YWwiLCJpbXBvcnRGaWxlIiwibWV0YWRhdGFSZXNwb25zZSIsImNvbnRlbnRSZXNwb25zZSIsImV4cG9ydFVybCIsImV4cG9ydFJlc3BvbnNlIiwidGV4dCIsImxpc3REcml2ZUZpbGVzIiwicXVlcnkiLCJsaXN0IiwicGFnZVNpemUiLCJxIiwib3JkZXJCeSIsImNvbnN0cnVjdG9yIiwiQ29uZmxpY3REZXRlY3Rpb25TZXJ2aWNlIiwiZGV0ZWN0Q29uZmxpY3RzIiwiY29udGVudEEiLCJjb250ZW50QiIsImNvbmZsaWN0cyIsInBhcmFncmFwaHNBIiwic3BsaXQiLCJwYXJhZ3JhcGhzQiIsInBhcmFBIiwibGVuZ3RoIiwiaW5jbHVkZXMiLCJwdXNoIiwic2VjdGlvbnMiLCJrZXl3b3Jkc0EiLCJleHRyYWN0S2V5d29yZHMiLCJrZXl3b3Jkc0IiLCJvcHBvc2l0ZUtleXdvcmRzIiwicG9zaXRpdmUiLCJuZWdhdGl2ZSIsImZpbmRTZW50ZW5jZXNXaXRoS2V5d29yZHMiLCJ3b3JkcyIsInRvTG93ZXJDYXNlIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwiZmlsdGVyIiwid29yZCIsInRleHRzIiwia2V5d29yZHMiLCJzZW50ZW5jZXMiLCJ0ZXh0U2VudGVuY2VzIiwicyIsInRyaW0iLCJzZW50ZW5jZSIsImtleXdvcmQiLCJnb29nbGVEcml2ZVNlcnZpY2UiLCJjb25mbGljdERldGVjdGlvblNlcnZpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/googleDrive.ts\n"));

/***/ })

});