"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./lib/googleDrive.ts":
/*!****************************!*\
  !*** ./lib/googleDrive.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConflictDetectionService: function() { return /* binding */ ConflictDetectionService; },\n/* harmony export */   GoogleDriveService: function() { return /* binding */ GoogleDriveService; },\n/* harmony export */   conflictDetectionService: function() { return /* binding */ conflictDetectionService; },\n/* harmony export */   googleDriveService: function() { return /* binding */ googleDriveService; }\n/* harmony export */ });\n/**\n * Google Drive API Integration Service\n * \n * This service handles the integration with Google Drive API for document management\n * and real-time collaboration.\n * \n * Google Cloud Project Setup Instructions:\n * 1. Create a new project in Google Cloud Console (https://console.cloud.google.com/)\n * 2. Enable the Google Drive API\n * 3. Configure OAuth consent screen\n *    - User Type: External\n *    - Application name: MUN Connect\n *    - Authorized domains: your-domain.com\n *    - Developer contact information: your-email@example.com\n * 4. Create OAuth 2.0 credentials\n *    - Application type: Web application\n *    - Name: MUN Connect Web Client\n *    - Authorized JavaScript origins: http://localhost:3000, https://your-domain.com\n *    - Authorized redirect URIs: http://localhost:3000/api/auth/callback/google, https://your-domain.com/api/auth/callback/google\n * 5. Add the following environment variables to your .env.local file:\n *    - GOOGLE_CLIENT_ID=your-client-id\n *    - GOOGLE_CLIENT_SECRET=your-client-secret\n *    - GOOGLE_API_KEY=your-api-key (for public API access)\n */ // Default configuration - these values should be replaced with environment variables\nconst DEFAULT_CONFIG = {\n    clientId: \"913358736520-5biusol4f5ead6t86d7rv94rd0ar3gkn.apps.googleusercontent.com\" || 0,\n    apiKey: \"AIzaSyB-pZ0FV758VUs_pIZ0Ck2iq5Wx0FDJCxw\" || 0,\n    scopes: [\n        \"https://www.googleapis.com/auth/drive.file\",\n        \"https://www.googleapis.com/auth/drive.appdata\"\n    ]\n};\n// Google Drive API Service\nclass GoogleDriveService {\n    /**\n   * Initialize the Google Drive API\n   * This loads the required libraries and initializes the API client\n   */ async initialize() {\n        if (this.initializationPromise) {\n            return this.initializationPromise;\n        }\n        this.initializationPromise = new Promise((resolve, reject)=>{\n            try {\n                // Load the Google API client library\n                const script1 = document.createElement(\"script\");\n                script1.src = \"https://apis.google.com/js/api.js\";\n                script1.async = true;\n                script1.defer = true;\n                script1.onload = ()=>{\n                    this.gapiLoaded = true;\n                    this.loadGapiClient().then(()=>{\n                        if (this.gisLoaded) resolve();\n                    }).catch(reject);\n                };\n                script1.onerror = (error)=>{\n                    console.error(\"Failed to load Google API client:\", error);\n                    reject(new Error(\"Failed to load Google API client\"));\n                };\n                document.body.appendChild(script1);\n                // Load the Google Identity Services library\n                const script2 = document.createElement(\"script\");\n                script2.src = \"https://accounts.google.com/gsi/client\";\n                script2.async = true;\n                script2.defer = true;\n                script2.onload = ()=>{\n                    this.gisLoaded = true;\n                    this.initializeTokenClient();\n                    if (this.gapiLoaded) resolve();\n                };\n                script2.onerror = (error)=>{\n                    console.error(\"Failed to load Google Identity Services:\", error);\n                    reject(new Error(\"Failed to load Google Identity Services\"));\n                };\n                document.body.appendChild(script2);\n            } catch (error) {\n                console.error(\"Error initializing Google Drive API:\", error);\n                reject(new Error(\"Error initializing Google Drive API: \".concat(error)));\n            }\n        });\n        return this.initializationPromise;\n    }\n    /**\n   * Load the Google API client library\n   */ async loadGapiClient() {\n        return new Promise((resolve, reject)=>{\n            try {\n                window.gapi.load(\"client\", {\n                    callback: async ()=>{\n                        try {\n                            await window.gapi.client.init({\n                                apiKey: this.config.apiKey,\n                                discoveryDocs: [\n                                    \"https://www.googleapis.com/discovery/v1/apis/drive/v3/rest\"\n                                ]\n                            });\n                            resolve();\n                        } catch (error) {\n                            reject(\"Error initializing GAPI client: \".concat(error));\n                        }\n                    },\n                    onerror: (error)=>reject(\"Error loading GAPI client: \".concat(error))\n                });\n            } catch (error) {\n                reject(\"Failed to load GAPI client: \".concat(error));\n            }\n        });\n    }\n    /**\n   * Initialize the Google Identity Services token client\n   */ initializeTokenClient() {\n        this.tokenClient = window.google.accounts.oauth2.initTokenClient({\n            client_id: this.config.clientId,\n            scope: this.config.scopes.join(\" \"),\n            callback: (tokenResponse)=>{\n                if (tokenResponse.error) {\n                    console.error(\"Error getting access token: \".concat(tokenResponse.error));\n                    return;\n                }\n                this.accessToken = tokenResponse.access_token;\n                window.gapi.client.setToken(tokenResponse);\n            }\n        });\n    }\n    /**\n   * Authenticate the user and request access to Google Drive\n   */ async authenticate() {\n        if (!this.initializationPromise) {\n            await this.initialize();\n        }\n        return new Promise((resolve)=>{\n            if (!this.tokenClient) {\n                console.error(\"Token client not initialized. Attempting to reinitialize...\");\n                this.initializeTokenClient();\n                if (!this.tokenClient) {\n                    throw new Error(\"Failed to initialize token client\");\n                }\n            }\n            try {\n                this.tokenClient.callback = (resp)=>{\n                    if (resp.error) {\n                        console.error(\"Error during authentication:\", resp.error);\n                        resolve(false);\n                        return;\n                    }\n                    this.accessToken = resp.access_token;\n                    window.gapi.client.setToken({\n                        access_token: this.accessToken\n                    });\n                    resolve(true);\n                };\n                if (!window.gapi.client.getToken()) {\n                    // Request an access token\n                    this.tokenClient.requestAccessToken({\n                        prompt: \"consent\"\n                    });\n                } else {\n                    // Already have an access token\n                    this.accessToken = window.gapi.client.getToken().access_token;\n                    resolve(true);\n                }\n            } catch (error) {\n                console.error(\"Error authenticating:\", error);\n                resolve(false);\n            }\n        });\n    }\n    /**\n   * Check if the user is authenticated\n   */ isAuthenticated() {\n        return this.accessToken !== null;\n    }\n    /**\n   * Create a new Google Doc for a document\n   * @param document The document to create a Google Doc for\n   * @returns The ID and web view link of the created Google Doc\n   */ async createGoogleDoc(document1) {\n        if (!this.isAuthenticated()) {\n            await this.authenticate();\n            if (!this.isAuthenticated()) {\n                throw new Error(\"Failed to authenticate with Google Drive\");\n            }\n        }\n        try {\n            // First, check if a doc with this ID already exists\n            const existingDocs = await window.gapi.client.drive.files.list({\n                q: \"properties has { key='munConnectDocId' and value='\".concat(document1.id, \"' }\"),\n                fields: \"files(id,webViewLink)\"\n            });\n            if (existingDocs.result.files && existingDocs.result.files.length > 0) {\n                console.log(\"Found existing Google Doc, returning its ID\");\n                return {\n                    id: existingDocs.result.files[0].id,\n                    webViewLink: existingDocs.result.files[0].webViewLink\n                };\n            }\n            // Create new document with metadata\n            const response = await window.gapi.client.drive.files.create({\n                resource: {\n                    name: document1.title,\n                    mimeType: \"application/vnd.google-apps.document\",\n                    description: \"MUN Connect document: \".concat(document1.type, \" for \").concat(document1.committee, \" - \").concat(document1.country),\n                    properties: {\n                        munConnectDocId: document1.id,\n                        documentType: document1.type,\n                        committee: document1.committee,\n                        country: document1.country,\n                        createdAt: new Date().toISOString(),\n                        lastSyncedAt: new Date().toISOString()\n                    }\n                },\n                fields: \"id,webViewLink,properties\"\n            });\n            if (!response.result.id) {\n                throw new Error(\"Created document is missing ID\");\n            }\n            // Cache the document metadata\n            try {\n                const cacheKey = \"doc_\".concat(document1.id);\n                localStorage.setItem(cacheKey, JSON.stringify({\n                    googleDocId: response.result.id,\n                    webViewLink: response.result.webViewLink,\n                    lastSynced: new Date().toISOString(),\n                    metadata: response.result.properties\n                }));\n            } catch (cacheError) {\n                console.warn(\"Failed to cache document metadata:\", cacheError);\n            // Non-blocking error - continue even if caching fails\n            }\n            return {\n                id: response.result.id,\n                webViewLink: response.result.webViewLink\n            };\n        } catch (error) {\n            var _error_result_error, _error_result;\n            console.error(\"Error creating Google Doc:\", error);\n            const errorMessage = ((_error_result = error.result) === null || _error_result === void 0 ? void 0 : (_error_result_error = _error_result.error) === null || _error_result_error === void 0 ? void 0 : _error_result_error.message) || error.message || \"Unknown error\";\n            throw new Error(\"Failed to create Google Doc: \".concat(errorMessage));\n        }\n    }\n    /**\n   * Get a Google Doc by its ID\n   * @param googleDocId The ID of the Google Doc to get\n   * @returns The Google Doc metadata\n   */ async getGoogleDoc(googleDocId) {\n        if (!this.isAuthenticated()) {\n            await this.authenticate();\n            if (!this.isAuthenticated()) {\n                throw new Error(\"Failed to authenticate with Google Drive\");\n            }\n        }\n        try {\n            // Check cache first\n            const cacheKey = \"doc_\".concat(googleDocId);\n            const cachedData = localStorage.getItem(cacheKey);\n            if (cachedData) {\n                const parsed = JSON.parse(cachedData);\n                const cacheAge = Date.now() - new Date(parsed.lastSynced).getTime();\n                // Use cache if it's less than 5 minutes old\n                if (cacheAge < 5 * 60 * 1000) {\n                    return parsed;\n                }\n            }\n            // Fetch fresh data\n            const response = await window.gapi.client.drive.files.get({\n                fileId: googleDocId,\n                fields: \"id,name,webViewLink,modifiedTime,capabilities,properties\"\n            });\n            if (!response.result) {\n                throw new Error(\"Failed to get document data\");\n            }\n            // Update cache\n            try {\n                localStorage.setItem(cacheKey, JSON.stringify({\n                    ...response.result,\n                    lastSynced: new Date().toISOString()\n                }));\n            } catch (cacheError) {\n                console.warn(\"Failed to update document cache:\", cacheError);\n            // Non-blocking error - continue even if caching fails\n            }\n            return response.result;\n        } catch (error) {\n            var _error_result_error, _error_result;\n            console.error(\"Error getting Google Doc:\", error);\n            const errorMessage = ((_error_result = error.result) === null || _error_result === void 0 ? void 0 : (_error_result_error = _error_result.error) === null || _error_result_error === void 0 ? void 0 : _error_result_error.message) || error.message || \"Unknown error\";\n            throw new Error(\"Failed to get Google Doc: \".concat(errorMessage));\n        }\n    }\n    /**\n   * Update a Google Doc's content\n   * @param googleDocId The ID of the Google Doc to update\n   * @param content The new content of the Google Doc\n   */ async updateGoogleDoc(googleDocId, content) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            // This is a simplified version. In a real implementation,\n            // you would use the Google Docs API to update the document content.\n            // For simplicity, we're just updating the document's metadata here.\n            await window.gapi.client.drive.files.update({\n                fileId: googleDocId,\n                resource: {\n                    properties: {\n                        lastUpdated: new Date().toISOString()\n                    }\n                }\n            });\n        } catch (error) {\n            console.error(\"Error updating Google Doc: \".concat(error));\n            throw new Error(\"Failed to update Google Doc: \".concat(error));\n        }\n    }\n    /**\n   * Export a Google Doc to a specific format (PDF, DOCX)\n   * @param googleDocId The ID of the Google Doc to export\n   * @param mimeType The mime type to export to (e.g., 'application/pdf')\n   * @returns A URL to download the exported file\n   */ async exportGoogleDoc(googleDocId, mimeType) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            const response = await fetch(\"https://www.googleapis.com/drive/v3/files/\".concat(googleDocId, \"/export?mimeType=\").concat(encodeURIComponent(mimeType)), {\n                headers: {\n                    Authorization: \"Bearer \".concat(this.accessToken)\n                }\n            });\n            if (!response.ok) {\n                throw new Error(\"Failed to export Google Doc: \".concat(response.statusText));\n            }\n            const blob = await response.blob();\n            return URL.createObjectURL(blob);\n        } catch (error) {\n            console.error(\"Error exporting Google Doc: \".concat(error));\n            throw new Error(\"Failed to export Google Doc: \".concat(error));\n        }\n    }\n    /**\n   * Watch for changes to a Google Doc\n   * This is a placeholder for real-time sync functionality.\n   * In a production environment, you would use the Google Drive API's\n   * watch method or establish a WebSocket connection.\n   * \n   * @param googleDocId The ID of the Google Doc to watch\n   * @param callback The callback to call when the Google Doc changes\n   * @returns A function to stop watching for changes\n   */ watchGoogleDoc(googleDocId, callback) {\n        // This is a placeholder. In a real implementation, you would use the Google Drive API's\n        // changes.watch method or establish a WebSocket connection.\n        const checkInterval = 5000; // Check every 5 seconds\n        let lastModified = null;\n        const intervalId = setInterval(async ()=>{\n            try {\n                if (!this.isAuthenticated()) {\n                    console.warn(\"Not authenticated with Google Drive\");\n                    return;\n                }\n                const doc = await this.getGoogleDoc(googleDocId);\n                if (lastModified !== null && doc.modifiedTime !== lastModified) {\n                    // Document has changed\n                    callback({\n                        documentId: googleDocId,\n                        modifiedTime: doc.modifiedTime\n                    });\n                }\n                lastModified = doc.modifiedTime;\n            } catch (error) {\n                console.error(\"Error checking for Google Doc changes: \".concat(error));\n            }\n        }, checkInterval);\n        // Return a function to stop watching for changes\n        return ()=>clearInterval(intervalId);\n    }\n    /**\n   * Import a file from Google Drive\n   * @param fileId The ID of the file to import\n   * @returns The imported file data\n   */ async importFile(fileId) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            // Get file metadata\n            const metadataResponse = await window.gapi.client.drive.files.get({\n                fileId,\n                fields: \"name,mimeType\"\n            });\n            const { name, mimeType } = metadataResponse.result;\n            // Get file content\n            const contentResponse = await fetch(\"https://www.googleapis.com/drive/v3/files/\".concat(fileId, \"?alt=media\"), {\n                headers: {\n                    Authorization: \"Bearer \".concat(this.accessToken)\n                }\n            });\n            if (!contentResponse.ok) {\n                throw new Error(\"Failed to get file content: \".concat(contentResponse.statusText));\n            }\n            let content = \"\";\n            if (mimeType === \"application/vnd.google-apps.document\") {\n                // Export Google Doc to text\n                const exportUrl = await this.exportGoogleDoc(fileId, \"text/plain\");\n                const exportResponse = await fetch(exportUrl);\n                content = await exportResponse.text();\n            } else {\n                // Get raw content for other file types\n                content = await contentResponse.text();\n            }\n            return {\n                name,\n                content,\n                mimeType\n            };\n        } catch (error) {\n            console.error(\"Error importing file: \".concat(error));\n            throw new Error(\"Failed to import file: \".concat(error));\n        }\n    }\n    /**\n   * List files from Google Drive\n   * @param query Optional search query to filter files\n   * @returns Array of Google Drive files\n   */ async listDriveFiles() {\n        let query = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            // Use the Google Drive API to list files\n            const response = await window.gapi.client.drive.files.list({\n                pageSize: 50,\n                fields: \"files(id, name, mimeType, modifiedTime, webViewLink)\",\n                q: query ? query : \"trashed = false\",\n                orderBy: \"modifiedTime desc\"\n            });\n            console.log(\"Google Drive files:\", response.result.files);\n            return response.result.files || [];\n        } catch (error) {\n            console.error(\"Error listing Drive files:\", error);\n            throw error;\n        }\n    }\n    constructor(config = {}){\n        this.gapiLoaded = false;\n        this.gisLoaded = false;\n        this.tokenClient = null;\n        this.accessToken = null;\n        this.initializationPromise = null;\n        this.config = {\n            ...DEFAULT_CONFIG,\n            ...config\n        };\n        if (!this.config.clientId) {\n            throw new Error(\"Google Client ID is required but not provided\");\n        }\n        if (!this.config.apiKey) {\n            throw new Error(\"Google API Key is required but not provided\");\n        }\n    }\n}\n/**\n * AI Conflict Detection Service\n * \n * This service implements a basic AI conflict detection algorithm\n * to flag conflicts between documents or content sections.\n * \n * In a production environment, this would integrate with an\n * actual NLP or AI service.\n */ class ConflictDetectionService {\n    /**\n   * Detect conflicts between document content sections\n   * @param contentA First content section\n   * @param contentB Second content section\n   * @returns Array of detected conflicts\n   */ detectConflicts(contentA, contentB) {\n        const conflicts = [];\n        // This is a very basic implementation for demonstration purposes\n        // Check for duplicate content (exact matches)\n        const paragraphsA = contentA.split(\"\\n\\n\");\n        const paragraphsB = contentB.split(\"\\n\\n\");\n        // Compare paragraphs for exact matches (simulating duplicate content detection)\n        for (const paraA of paragraphsA){\n            if (paraA.length > 50 && paragraphsB.includes(paraA)) {\n                conflicts.push({\n                    type: \"duplicate_content\",\n                    description: \"Duplicate paragraph detected\",\n                    sections: [\n                        paraA\n                    ]\n                });\n            }\n        }\n        // Simulating conflicting perspective detection\n        // In a real implementation, this would use NLP to detect contradictory statements\n        const keywordsA = this.extractKeywords(contentA);\n        const keywordsB = this.extractKeywords(contentB);\n        // Check for opposite sentiment keywords (very simplified approach)\n        const oppositeKeywords = [\n            [\n                \"support\",\n                \"oppose\"\n            ],\n            [\n                \"agree\",\n                \"disagree\"\n            ],\n            [\n                \"approve\",\n                \"disapprove\"\n            ],\n            [\n                \"increase\",\n                \"decrease\"\n            ],\n            [\n                \"positive\",\n                \"negative\"\n            ]\n        ];\n        for (const [positive, negative] of oppositeKeywords){\n            if (keywordsA.includes(positive) && keywordsB.includes(negative) || keywordsA.includes(negative) && keywordsB.includes(positive)) {\n                conflicts.push({\n                    type: \"conflicting_perspective\",\n                    description: 'Potentially conflicting positions: \"'.concat(positive, '\" vs \"').concat(negative, '\"'),\n                    sections: this.findSentencesWithKeywords([\n                        contentA,\n                        contentB\n                    ], [\n                        positive,\n                        negative\n                    ])\n                });\n            }\n        }\n        return conflicts;\n    }\n    /**\n   * Extract keywords from text (simplified implementation)\n   * @param text The text to extract keywords from\n   * @returns Array of extracted keywords\n   */ extractKeywords(text) {\n        // This is a simplified implementation.\n        // In a real app, you would use a proper NLP library for keyword extraction.\n        const words = text.toLowerCase().split(/\\W+/);\n        return Array.from(new Set(words.filter((word)=>word.length > 3)));\n    }\n    /**\n   * Find sentences containing specific keywords\n   * @param texts Array of text blocks to search in\n   * @param keywords Keywords to search for\n   * @returns Array of sentences containing the keywords\n   */ findSentencesWithKeywords(texts, keywords) {\n        const sentences = [];\n        // Split texts into sentences and find those containing keywords\n        for (const text of texts){\n            const textSentences = text.split(/[.!?]+/).filter((s)=>s.trim().length > 0);\n            for (const sentence of textSentences){\n                for (const keyword of keywords){\n                    if (sentence.toLowerCase().includes(keyword.toLowerCase())) {\n                        sentences.push(sentence.trim());\n                        break;\n                    }\n                }\n            }\n        }\n        return sentences;\n    }\n}\n// Create singleton instances for use throughout the application\nconst googleDriveService = new GoogleDriveService();\nconst conflictDetectionService = new ConflictDetectionService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9nb29nbGVEcml2ZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBdUJDLEdBV0QscUZBQXFGO0FBQ3JGLE1BQU1BLGlCQUFvQztJQUN4Q0MsVUFBVUMsMEVBQXdDLElBQUk7SUFDdERHLFFBQVFILHlDQUFzQyxJQUFJO0lBQ2xESyxRQUFRO1FBQ047UUFDQTtLQUNEO0FBQ0g7QUFFQSwyQkFBMkI7QUFDcEIsTUFBTUM7SUFrQlg7OztHQUdDLEdBQ0QsTUFBTUMsYUFBNEI7UUFDaEMsSUFBSSxJQUFJLENBQUNDLHFCQUFxQixFQUFFO1lBQzlCLE9BQU8sSUFBSSxDQUFDQSxxQkFBcUI7UUFDbkM7UUFFQSxJQUFJLENBQUNBLHFCQUFxQixHQUFHLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDakQsSUFBSTtnQkFDRixxQ0FBcUM7Z0JBQ3JDLE1BQU1DLFVBQVVDLFNBQVNDLGFBQWEsQ0FBQztnQkFDdkNGLFFBQVFHLEdBQUcsR0FBRztnQkFDZEgsUUFBUUksS0FBSyxHQUFHO2dCQUNoQkosUUFBUUssS0FBSyxHQUFHO2dCQUNoQkwsUUFBUU0sTUFBTSxHQUFHO29CQUNmLElBQUksQ0FBQ0MsVUFBVSxHQUFHO29CQUNsQixJQUFJLENBQUNDLGNBQWMsR0FBR0MsSUFBSSxDQUFDO3dCQUN6QixJQUFJLElBQUksQ0FBQ0MsU0FBUyxFQUFFWjtvQkFDdEIsR0FBR2EsS0FBSyxDQUFDWjtnQkFDWDtnQkFDQUMsUUFBUVksT0FBTyxHQUFHLENBQUNDO29CQUNqQkMsUUFBUUQsS0FBSyxDQUFDLHFDQUFxQ0E7b0JBQ25EZCxPQUFPLElBQUlnQixNQUFNO2dCQUNuQjtnQkFDQWQsU0FBU2UsSUFBSSxDQUFDQyxXQUFXLENBQUNqQjtnQkFFMUIsNENBQTRDO2dCQUM1QyxNQUFNa0IsVUFBVWpCLFNBQVNDLGFBQWEsQ0FBQztnQkFDdkNnQixRQUFRZixHQUFHLEdBQUc7Z0JBQ2RlLFFB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V0FBV04sU0FBVTtvQkFDOUIsSUFBSUssU0FBU1osV0FBVyxHQUFHWCxRQUFRLENBQUN3QixRQUFRYixXQUFXLEtBQUs7d0JBQzFEUSxVQUFVbEIsSUFBSSxDQUFDc0IsU0FBU0QsSUFBSTt3QkFDNUI7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsT0FBT0g7SUFDVDtBQUNGO0FBRUEsZ0VBQWdFO0FBQ3pELE1BQU1NLHFCQUFxQixJQUFJM0sscUJBQXFCO0FBQ3BELE1BQU00SywyQkFBMkIsSUFBSW5DLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvZ29vZ2xlRHJpdmUudHM/NTc1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdvb2dsZSBEcml2ZSBBUEkgSW50ZWdyYXRpb24gU2VydmljZVxuICogXG4gKiBUaGlzIHNlcnZpY2UgaGFuZGxlcyB0aGUgaW50ZWdyYXRpb24gd2l0aCBHb29nbGUgRHJpdmUgQVBJIGZvciBkb2N1bWVudCBtYW5hZ2VtZW50XG4gKiBhbmQgcmVhbC10aW1lIGNvbGxhYm9yYXRpb24uXG4gKiBcbiAqIEdvb2dsZSBDbG91ZCBQcm9qZWN0IFNldHVwIEluc3RydWN0aW9uczpcbiAqIDEuIENyZWF0ZSBhIG5ldyBwcm9qZWN0IGluIEdvb2dsZSBDbG91ZCBDb25zb2xlIChodHRwczovL2NvbnNvbGUuY2xvdWQuZ29vZ2xlLmNvbS8pXG4gKiAyLiBFbmFibGUgdGhlIEdvb2dsZSBEcml2ZSBBUElcbiAqIDMuIENvbmZpZ3VyZSBPQXV0aCBjb25zZW50IHNjcmVlblxuICogICAgLSBVc2VyIFR5cGU6IEV4dGVybmFsXG4gKiAgICAtIEFwcGxpY2F0aW9uIG5hbWU6IE1VTiBDb25uZWN0XG4gKiAgICAtIEF1dGhvcml6ZWQgZG9tYWluczogeW91ci1kb21haW4uY29tXG4gKiAgICAtIERldmVsb3BlciBjb250YWN0IGluZm9ybWF0aW9uOiB5b3VyLWVtYWlsQGV4YW1wbGUuY29tXG4gKiA0LiBDcmVhdGUgT0F1dGggMi4wIGNyZWRlbnRpYWxzXG4gKiAgICAtIEFwcGxpY2F0aW9uIHR5cGU6IFdlYiBhcHBsaWNhdGlvblxuICogICAgLSBOYW1lOiBNVU4gQ29ubmVjdCBXZWIgQ2xpZW50XG4gKiAgICAtIEF1dGhvcml6ZWQgSmF2YVNjcmlwdCBvcmlnaW5zOiBodHRwOi8vbG9jYWxob3N0OjMwMDAsIGh0dHBzOi8veW91ci1kb21haW4uY29tXG4gKiAgICAtIEF1dGhvcml6ZWQgcmVkaXJlY3QgVVJJczogaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2NhbGxiYWNrL2dvb2dsZSwgaHR0cHM6Ly95b3VyLWRvbWFpbi5jb20vYXBpL2F1dGgvY2FsbGJhY2svZ29vZ2xlXG4gKiA1LiBBZGQgdGhlIGZvbGxvd2luZyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8geW91ciAuZW52LmxvY2FsIGZpbGU6XG4gKiAgICAtIEdPT0dMRV9DTElFTlRfSUQ9eW91ci1jbGllbnQtaWRcbiAqICAgIC0gR09PR0xFX0NMSUVOVF9TRUNSRVQ9eW91ci1jbGllbnQtc2VjcmV0XG4gKiAgICAtIEdPT0dMRV9BUElfS0VZPXlvdXItYXBpLWtleSAoZm9yIHB1YmxpYyBBUEkgYWNjZXNzKVxuICovXG5cbmltcG9ydCB7IERvY3VtZW50IH0gZnJvbSAnLi9kb2N1bWVudCc7XG5cbi8vIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgR29vZ2xlIERyaXZlIEFQSVxuaW50ZXJmYWNlIEdvb2dsZURyaXZlQ29uZmlnIHtcbiAgY2xpZW50SWQ6IHN0cmluZztcbiAgYXBpS2V5OiBzdHJpbmc7XG4gIHNjb3Blczogc3RyaW5nW107XG59XG5cbi8vIERlZmF1bHQgY29uZmlndXJhdGlvbiAtIHRoZXNlIHZhbHVlcyBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbmNvbnN0IERFRkFVTFRfQ09ORklHOiBHb29nbGVEcml2ZUNvbmZpZyA9IHtcbiAgY2xpZW50SWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0dPT0dMRV9DTElFTlRfSUQgfHwgJycsXG4gIGFwaUtleTogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX0FQSV9LRVkgfHwgJycsXG4gIHNjb3BlczogW1xuICAgICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2RyaXZlLmZpbGUnLFxuICAgICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2RyaXZlLmFwcGRhdGEnLFxuICBdLFxufTtcblxuLy8gR29vZ2xlIERyaXZlIEFQSSBTZXJ2aWNlXG5leHBvcnQgY2xhc3MgR29vZ2xlRHJpdmVTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBnYXBpTG9hZGVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgZ2lzTG9hZGVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgdG9rZW5DbGllbnQ6IGFueSA9IG51bGw7XG4gIHByaXZhdGUgYWNjZXNzVG9rZW46IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGNvbmZpZzogR29vZ2xlRHJpdmVDb25maWc7XG4gIHByaXZhdGUgaW5pdGlhbGl6YXRpb25Qcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XG4gIFxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFBhcnRpYWw8R29vZ2xlRHJpdmVDb25maWc+ID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHsgLi4uREVGQVVMVF9DT05GSUcsIC4uLmNvbmZpZyB9O1xuICAgIGlmICghdGhpcy5jb25maWcuY2xpZW50SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR29vZ2xlIENsaWVudCBJRCBpcyByZXF1aXJlZCBidXQgbm90IHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb25maWcuYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dvb2dsZSBBUEkgS2V5IGlzIHJlcXVpcmVkIGJ1dCBub3QgcHJvdmlkZWQnKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBHb29nbGUgRHJpdmUgQVBJXG4gICAqIFRoaXMgbG9hZHMgdGhlIHJlcXVpcmVkIGxpYnJhcmllcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIEFQSSBjbGllbnRcbiAgICovXG4gIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6YXRpb25Qcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsaXphdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBMb2FkIHRoZSBHb29nbGUgQVBJIGNsaWVudCBsaWJyYXJ5XG4gICAgICAgIGNvbnN0IHNjcmlwdDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0MS5zcmMgPSAnaHR0cHM6Ly9hcGlzLmdvb2dsZS5jb20vanMvYXBpLmpzJztcbiAgICAgICAgc2NyaXB0MS5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdDEuZGVmZXIgPSB0cnVlO1xuICAgICAgICBzY3JpcHQxLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmdhcGlMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMubG9hZEdhcGlDbGllbnQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdpc0xvYWRlZCkgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIHNjcmlwdDEub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIEdvb2dsZSBBUEkgY2xpZW50OicsIGVycm9yKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBHb29nbGUgQVBJIGNsaWVudCcpKTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQxKTtcbiAgICAgICAgXG4gICAgICAgIC8vIExvYWQgdGhlIEdvb2dsZSBJZGVudGl0eSBTZXJ2aWNlcyBsaWJyYXJ5XG4gICAgICAgIGNvbnN0IHNjcmlwdDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0Mi5zcmMgPSAnaHR0cHM6Ly9hY2NvdW50cy5nb29nbGUuY29tL2dzaS9jbGllbnQnO1xuICAgICAgICBzY3JpcHQyLmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0Mi5kZWZlciA9IHRydWU7XG4gICAgICAgIHNjcmlwdDIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZ2lzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemVUb2tlbkNsaWVudCgpO1xuICAgICAgICAgIGlmICh0aGlzLmdhcGlMb2FkZWQpIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2NyaXB0Mi5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgR29vZ2xlIElkZW50aXR5IFNlcnZpY2VzOicsIGVycm9yKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBHb29nbGUgSWRlbnRpdHkgU2VydmljZXMnKSk7XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0Mik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgR29vZ2xlIERyaXZlIEFQSTonLCBlcnJvcik7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEVycm9yIGluaXRpYWxpemluZyBHb29nbGUgRHJpdmUgQVBJOiAke2Vycm9yfWApKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmluaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIExvYWQgdGhlIEdvb2dsZSBBUEkgY2xpZW50IGxpYnJhcnlcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgbG9hZEdhcGlDbGllbnQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdpbmRvdy5nYXBpLmxvYWQoJ2NsaWVudCcsIHtcbiAgICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgd2luZG93LmdhcGkuY2xpZW50LmluaXQoe1xuICAgICAgICAgICAgICAgIGFwaUtleTogdGhpcy5jb25maWcuYXBpS2V5LFxuICAgICAgICAgICAgICAgIGRpc2NvdmVyeURvY3M6IFsnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vZGlzY292ZXJ5L3YxL2FwaXMvZHJpdmUvdjMvcmVzdCddLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGBFcnJvciBpbml0aWFsaXppbmcgR0FQSSBjbGllbnQ6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbmVycm9yOiAoZXJyb3I6IGFueSkgPT4gcmVqZWN0KGBFcnJvciBsb2FkaW5nIEdBUEkgY2xpZW50OiAke2Vycm9yfWApLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChgRmFpbGVkIHRvIGxvYWQgR0FQSSBjbGllbnQ6ICR7ZXJyb3J9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBHb29nbGUgSWRlbnRpdHkgU2VydmljZXMgdG9rZW4gY2xpZW50XG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVUb2tlbkNsaWVudCgpOiB2b2lkIHtcbiAgICB0aGlzLnRva2VuQ2xpZW50ID0gd2luZG93Lmdvb2dsZS5hY2NvdW50cy5vYXV0aDIuaW5pdFRva2VuQ2xpZW50KHtcbiAgICAgIGNsaWVudF9pZDogdGhpcy5jb25maWcuY2xpZW50SWQsXG4gICAgICBzY29wZTogdGhpcy5jb25maWcuc2NvcGVzLmpvaW4oJyAnKSxcbiAgICAgIGNhbGxiYWNrOiAodG9rZW5SZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgIGlmICh0b2tlblJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2V0dGluZyBhY2Nlc3MgdG9rZW46ICR7dG9rZW5SZXNwb25zZS5lcnJvcn1gKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHRva2VuUmVzcG9uc2UuYWNjZXNzX3Rva2VuO1xuICAgICAgICB3aW5kb3cuZ2FwaS5jbGllbnQuc2V0VG9rZW4odG9rZW5SZXNwb25zZSk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogQXV0aGVudGljYXRlIHRoZSB1c2VyIGFuZCByZXF1ZXN0IGFjY2VzcyB0byBHb29nbGUgRHJpdmVcbiAgICovXG4gIGFzeW5jIGF1dGhlbnRpY2F0ZSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6YXRpb25Qcm9taXNlKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGlmICghdGhpcy50b2tlbkNsaWVudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUb2tlbiBjbGllbnQgbm90IGluaXRpYWxpemVkLiBBdHRlbXB0aW5nIHRvIHJlaW5pdGlhbGl6ZS4uLicpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVUb2tlbkNsaWVudCgpO1xuICAgICAgICBpZiAoIXRoaXMudG9rZW5DbGllbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIHRva2VuIGNsaWVudCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMudG9rZW5DbGllbnQuY2FsbGJhY2sgPSAocmVzcDogYW55KSA9PiB7XG4gICAgICAgICAgaWYgKHJlc3AuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBhdXRoZW50aWNhdGlvbjonLCByZXNwLmVycm9yKTtcbiAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gcmVzcC5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgd2luZG93LmdhcGkuY2xpZW50LnNldFRva2VuKHsgYWNjZXNzX3Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuIH0pO1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBpZiAoIXdpbmRvdy5nYXBpLmNsaWVudC5nZXRUb2tlbigpKSB7XG4gICAgICAgICAgLy8gUmVxdWVzdCBhbiBhY2Nlc3MgdG9rZW5cbiAgICAgICAgICB0aGlzLnRva2VuQ2xpZW50LnJlcXVlc3RBY2Nlc3NUb2tlbih7IHByb21wdDogJ2NvbnNlbnQnIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFscmVhZHkgaGF2ZSBhbiBhY2Nlc3MgdG9rZW5cbiAgICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gd2luZG93LmdhcGkuY2xpZW50LmdldFRva2VuKCkuYWNjZXNzX3Rva2VuO1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGF1dGhlbnRpY2F0aW5nOicsIGVycm9yKTtcbiAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgdXNlciBpcyBhdXRoZW50aWNhdGVkXG4gICAqL1xuICBpc0F1dGhlbnRpY2F0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYWNjZXNzVG9rZW4gIT09IG51bGw7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgR29vZ2xlIERvYyBmb3IgYSBkb2N1bWVudFxuICAgKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIGNyZWF0ZSBhIEdvb2dsZSBEb2MgZm9yXG4gICAqIEByZXR1cm5zIFRoZSBJRCBhbmQgd2ViIHZpZXcgbGluayBvZiB0aGUgY3JlYXRlZCBHb29nbGUgRG9jXG4gICAqL1xuICBhc3luYyBjcmVhdGVHb29nbGVEb2MoZG9jdW1lbnQ6IERvY3VtZW50KTogUHJvbWlzZTx7IGlkOiBzdHJpbmc7IHdlYlZpZXdMaW5rOiBzdHJpbmcgfT4ge1xuICAgIGlmICghdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgICAgYXdhaXQgdGhpcy5hdXRoZW50aWNhdGUoKTtcbiAgICAgIGlmICghdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBhdXRoZW50aWNhdGUgd2l0aCBHb29nbGUgRHJpdmUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0LCBjaGVjayBpZiBhIGRvYyB3aXRoIHRoaXMgSUQgYWxyZWFkeSBleGlzdHNcbiAgICAgIGNvbnN0IGV4aXN0aW5nRG9jcyA9IGF3YWl0IHdpbmRvdy5nYXBpLmNsaWVudC5kcml2ZS5maWxlcy5saXN0KHtcbiAgICAgICAgcTogYHByb3BlcnRpZXMgaGFzIHsga2V5PSdtdW5Db25uZWN0RG9jSWQnIGFuZCB2YWx1ZT0nJHtkb2N1bWVudC5pZH0nIH1gLFxuICAgICAgICBmaWVsZHM6ICdmaWxlcyhpZCx3ZWJWaWV3TGluayknLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChleGlzdGluZ0RvY3MucmVzdWx0LmZpbGVzICYmIGV4aXN0aW5nRG9jcy5yZXN1bHQuZmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgZXhpc3RpbmcgR29vZ2xlIERvYywgcmV0dXJuaW5nIGl0cyBJRCcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBleGlzdGluZ0RvY3MucmVzdWx0LmZpbGVzWzBdLmlkLFxuICAgICAgICAgIHdlYlZpZXdMaW5rOiBleGlzdGluZ0RvY3MucmVzdWx0LmZpbGVzWzBdLndlYlZpZXdMaW5rLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgbmV3IGRvY3VtZW50IHdpdGggbWV0YWRhdGFcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgd2luZG93LmdhcGkuY2xpZW50LmRyaXZlLmZpbGVzLmNyZWF0ZSh7XG4gICAgICAgIHJlc291cmNlOiB7XG4gICAgICAgICAgbmFtZTogZG9jdW1lbnQudGl0bGUsXG4gICAgICAgICAgbWltZVR5cGU6ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWFwcHMuZG9jdW1lbnQnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgTVVOIENvbm5lY3QgZG9jdW1lbnQ6ICR7ZG9jdW1lbnQudHlwZX0gZm9yICR7ZG9jdW1lbnQuY29tbWl0dGVlfSAtICR7ZG9jdW1lbnQuY291bnRyeX1gLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIG11bkNvbm5lY3REb2NJZDogZG9jdW1lbnQuaWQsXG4gICAgICAgICAgICBkb2N1bWVudFR5cGU6IGRvY3VtZW50LnR5cGUsXG4gICAgICAgICAgICBjb21taXR0ZWU6IGRvY3VtZW50LmNvbW1pdHRlZSxcbiAgICAgICAgICAgIGNvdW50cnk6IGRvY3VtZW50LmNvdW50cnksXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGxhc3RTeW5jZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGZpZWxkczogJ2lkLHdlYlZpZXdMaW5rLHByb3BlcnRpZXMnLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2UucmVzdWx0LmlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3JlYXRlZCBkb2N1bWVudCBpcyBtaXNzaW5nIElEJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhY2hlIHRoZSBkb2N1bWVudCBtZXRhZGF0YVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBgZG9jXyR7ZG9jdW1lbnQuaWR9YDtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oY2FjaGVLZXksIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBnb29nbGVEb2NJZDogcmVzcG9uc2UucmVzdWx0LmlkLFxuICAgICAgICAgIHdlYlZpZXdMaW5rOiByZXNwb25zZS5yZXN1bHQud2ViVmlld0xpbmssXG4gICAgICAgICAgbGFzdFN5bmNlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIG1ldGFkYXRhOiByZXNwb25zZS5yZXN1bHQucHJvcGVydGllcyxcbiAgICAgICAgfSkpO1xuICAgICAgfSBjYXRjaCAoY2FjaGVFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjYWNoZSBkb2N1bWVudCBtZXRhZGF0YTonLCBjYWNoZUVycm9yKTtcbiAgICAgICAgLy8gTm9uLWJsb2NraW5nIGVycm9yIC0gY29udGludWUgZXZlbiBpZiBjYWNoaW5nIGZhaWxzXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiByZXNwb25zZS5yZXN1bHQuaWQsXG4gICAgICAgIHdlYlZpZXdMaW5rOiByZXNwb25zZS5yZXN1bHQud2ViVmlld0xpbmssXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIEdvb2dsZSBEb2M6JywgZXJyb3IpO1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IucmVzdWx0Py5lcnJvcj8ubWVzc2FnZSB8fCBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJztcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBHb29nbGUgRG9jOiAke2Vycm9yTWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBHb29nbGUgRG9jIGJ5IGl0cyBJRFxuICAgKiBAcGFyYW0gZ29vZ2xlRG9jSWQgVGhlIElEIG9mIHRoZSBHb29nbGUgRG9jIHRvIGdldFxuICAgKiBAcmV0dXJucyBUaGUgR29vZ2xlIERvYyBtZXRhZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0R29vZ2xlRG9jKGdvb2dsZURvY0lkOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgICAgYXdhaXQgdGhpcy5hdXRoZW50aWNhdGUoKTtcbiAgICAgIGlmICghdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBhdXRoZW50aWNhdGUgd2l0aCBHb29nbGUgRHJpdmUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0XG4gICAgICBjb25zdCBjYWNoZUtleSA9IGBkb2NfJHtnb29nbGVEb2NJZH1gO1xuICAgICAgY29uc3QgY2FjaGVkRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGNhY2hlS2V5KTtcbiAgICAgIFxuICAgICAgaWYgKGNhY2hlZERhdGEpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShjYWNoZWREYXRhKTtcbiAgICAgICAgY29uc3QgY2FjaGVBZ2UgPSBEYXRlLm5vdygpIC0gbmV3IERhdGUocGFyc2VkLmxhc3RTeW5jZWQpLmdldFRpbWUoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVzZSBjYWNoZSBpZiBpdCdzIGxlc3MgdGhhbiA1IG1pbnV0ZXMgb2xkXG4gICAgICAgIGlmIChjYWNoZUFnZSA8IDUgKiA2MCAqIDEwMDApIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZldGNoIGZyZXNoIGRhdGFcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgd2luZG93LmdhcGkuY2xpZW50LmRyaXZlLmZpbGVzLmdldCh7XG4gICAgICAgIGZpbGVJZDogZ29vZ2xlRG9jSWQsXG4gICAgICAgIGZpZWxkczogJ2lkLG5hbWUsd2ViVmlld0xpbmssbW9kaWZpZWRUaW1lLGNhcGFiaWxpdGllcyxwcm9wZXJ0aWVzJyxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLnJlc3VsdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgZG9jdW1lbnQgZGF0YScpO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgY2FjaGVcbiAgICAgIHRyeSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGNhY2hlS2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgLi4ucmVzcG9uc2UucmVzdWx0LFxuICAgICAgICAgIGxhc3RTeW5jZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSkpO1xuICAgICAgfSBjYXRjaCAoY2FjaGVFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB1cGRhdGUgZG9jdW1lbnQgY2FjaGU6JywgY2FjaGVFcnJvcik7XG4gICAgICAgIC8vIE5vbi1ibG9ja2luZyBlcnJvciAtIGNvbnRpbnVlIGV2ZW4gaWYgY2FjaGluZyBmYWlsc1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgR29vZ2xlIERvYzonLCBlcnJvcik7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvci5yZXN1bHQ/LmVycm9yPy5tZXNzYWdlIHx8IGVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IEdvb2dsZSBEb2M6ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFVwZGF0ZSBhIEdvb2dsZSBEb2MncyBjb250ZW50XG4gICAqIEBwYXJhbSBnb29nbGVEb2NJZCBUaGUgSUQgb2YgdGhlIEdvb2dsZSBEb2MgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSBjb250ZW50IFRoZSBuZXcgY29udGVudCBvZiB0aGUgR29vZ2xlIERvY1xuICAgKi9cbiAgYXN5bmMgdXBkYXRlR29vZ2xlRG9jKGdvb2dsZURvY0lkOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCB3aXRoIEdvb2dsZSBEcml2ZScpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgdmVyc2lvbi4gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLFxuICAgICAgLy8geW91IHdvdWxkIHVzZSB0aGUgR29vZ2xlIERvY3MgQVBJIHRvIHVwZGF0ZSB0aGUgZG9jdW1lbnQgY29udGVudC5cbiAgICAgIC8vIEZvciBzaW1wbGljaXR5LCB3ZSdyZSBqdXN0IHVwZGF0aW5nIHRoZSBkb2N1bWVudCdzIG1ldGFkYXRhIGhlcmUuXG4gICAgICBhd2FpdCB3aW5kb3cuZ2FwaS5jbGllbnQuZHJpdmUuZmlsZXMudXBkYXRlKHtcbiAgICAgICAgZmlsZUlkOiBnb29nbGVEb2NJZCxcbiAgICAgICAgcmVzb3VyY2U6IHtcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgdXBkYXRpbmcgR29vZ2xlIERvYzogJHtlcnJvcn1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSBHb29nbGUgRG9jOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIEV4cG9ydCBhIEdvb2dsZSBEb2MgdG8gYSBzcGVjaWZpYyBmb3JtYXQgKFBERiwgRE9DWClcbiAgICogQHBhcmFtIGdvb2dsZURvY0lkIFRoZSBJRCBvZiB0aGUgR29vZ2xlIERvYyB0byBleHBvcnRcbiAgICogQHBhcmFtIG1pbWVUeXBlIFRoZSBtaW1lIHR5cGUgdG8gZXhwb3J0IHRvIChlLmcuLCAnYXBwbGljYXRpb24vcGRmJylcbiAgICogQHJldHVybnMgQSBVUkwgdG8gZG93bmxvYWQgdGhlIGV4cG9ydGVkIGZpbGVcbiAgICovXG4gIGFzeW5jIGV4cG9ydEdvb2dsZURvYyhnb29nbGVEb2NJZDogc3RyaW5nLCBtaW1lVHlwZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuaXNBdXRoZW50aWNhdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhlbnRpY2F0ZWQgd2l0aCBHb29nbGUgRHJpdmUnKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgIGBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9kcml2ZS92My9maWxlcy8ke2dvb2dsZURvY0lkfS9leHBvcnQ/bWltZVR5cGU9JHtlbmNvZGVVUklDb21wb25lbnQobWltZVR5cGUpfWAsXG4gICAgICAgIHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5hY2Nlc3NUb2tlbn1gLFxuICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZXhwb3J0IEdvb2dsZSBEb2M6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBleHBvcnRpbmcgR29vZ2xlIERvYzogJHtlcnJvcn1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGV4cG9ydCBHb29nbGUgRG9jOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFdhdGNoIGZvciBjaGFuZ2VzIHRvIGEgR29vZ2xlIERvY1xuICAgKiBUaGlzIGlzIGEgcGxhY2Vob2xkZXIgZm9yIHJlYWwtdGltZSBzeW5jIGZ1bmN0aW9uYWxpdHkuXG4gICAqIEluIGEgcHJvZHVjdGlvbiBlbnZpcm9ubWVudCwgeW91IHdvdWxkIHVzZSB0aGUgR29vZ2xlIERyaXZlIEFQSSdzXG4gICAqIHdhdGNoIG1ldGhvZCBvciBlc3RhYmxpc2ggYSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgICogXG4gICAqIEBwYXJhbSBnb29nbGVEb2NJZCBUaGUgSUQgb2YgdGhlIEdvb2dsZSBEb2MgdG8gd2F0Y2hcbiAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gdGhlIEdvb2dsZSBEb2MgY2hhbmdlc1xuICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRvIHN0b3Agd2F0Y2hpbmcgZm9yIGNoYW5nZXNcbiAgICovXG4gIHdhdGNoR29vZ2xlRG9jKGdvb2dsZURvY0lkOiBzdHJpbmcsIGNhbGxiYWNrOiAoY2hhbmdlczogYW55KSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gICAgLy8gVGhpcyBpcyBhIHBsYWNlaG9sZGVyLiBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHlvdSB3b3VsZCB1c2UgdGhlIEdvb2dsZSBEcml2ZSBBUEknc1xuICAgIC8vIGNoYW5nZXMud2F0Y2ggbWV0aG9kIG9yIGVzdGFibGlzaCBhIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgIGNvbnN0IGNoZWNrSW50ZXJ2YWwgPSA1MDAwOyAvLyBDaGVjayBldmVyeSA1IHNlY29uZHNcbiAgICBsZXQgbGFzdE1vZGlmaWVkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICBcbiAgICBjb25zdCBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdOb3QgYXV0aGVudGljYXRlZCB3aXRoIEdvb2dsZSBEcml2ZScpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgZG9jID0gYXdhaXQgdGhpcy5nZXRHb29nbGVEb2MoZ29vZ2xlRG9jSWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGxhc3RNb2RpZmllZCAhPT0gbnVsbCAmJiBkb2MubW9kaWZpZWRUaW1lICE9PSBsYXN0TW9kaWZpZWQpIHtcbiAgICAgICAgICAvLyBEb2N1bWVudCBoYXMgY2hhbmdlZFxuICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgIGRvY3VtZW50SWQ6IGdvb2dsZURvY0lkLFxuICAgICAgICAgICAgbW9kaWZpZWRUaW1lOiBkb2MubW9kaWZpZWRUaW1lLFxuICAgICAgICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB5b3Ugd291bGQgaW5jbHVkZSB0aGUgYWN0dWFsIGNoYW5nZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbGFzdE1vZGlmaWVkID0gZG9jLm1vZGlmaWVkVGltZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNoZWNraW5nIGZvciBHb29nbGUgRG9jIGNoYW5nZXM6ICR7ZXJyb3J9YCk7XG4gICAgICB9XG4gICAgfSwgY2hlY2tJbnRlcnZhbCk7XG4gICAgXG4gICAgLy8gUmV0dXJuIGEgZnVuY3Rpb24gdG8gc3RvcCB3YXRjaGluZyBmb3IgY2hhbmdlc1xuICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICB9XG4gIFxuICAvKipcbiAgICogSW1wb3J0IGEgZmlsZSBmcm9tIEdvb2dsZSBEcml2ZVxuICAgKiBAcGFyYW0gZmlsZUlkIFRoZSBJRCBvZiB0aGUgZmlsZSB0byBpbXBvcnRcbiAgICogQHJldHVybnMgVGhlIGltcG9ydGVkIGZpbGUgZGF0YVxuICAgKi9cbiAgYXN5bmMgaW1wb3J0RmlsZShmaWxlSWQ6IHN0cmluZyk6IFByb21pc2U8eyBuYW1lOiBzdHJpbmc7IGNvbnRlbnQ6IHN0cmluZzsgbWltZVR5cGU6IHN0cmluZyB9PiB7XG4gICAgaWYgKCF0aGlzLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRoZW50aWNhdGVkIHdpdGggR29vZ2xlIERyaXZlJyk7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgZmlsZSBtZXRhZGF0YVxuICAgICAgY29uc3QgbWV0YWRhdGFSZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5nYXBpLmNsaWVudC5kcml2ZS5maWxlcy5nZXQoe1xuICAgICAgICBmaWxlSWQsXG4gICAgICAgIGZpZWxkczogJ25hbWUsbWltZVR5cGUnLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgbmFtZSwgbWltZVR5cGUgfSA9IG1ldGFkYXRhUmVzcG9uc2UucmVzdWx0O1xuICAgICAgXG4gICAgICAvLyBHZXQgZmlsZSBjb250ZW50XG4gICAgICBjb25zdCBjb250ZW50UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2RyaXZlL3YzL2ZpbGVzLyR7ZmlsZUlkfT9hbHQ9bWVkaWFgLFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuYWNjZXNzVG9rZW59YCxcbiAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAoIWNvbnRlbnRSZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgZmlsZSBjb250ZW50OiAke2NvbnRlbnRSZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBsZXQgY29udGVudCA9ICcnO1xuICAgICAgXG4gICAgICBpZiAobWltZVR5cGUgPT09ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWFwcHMuZG9jdW1lbnQnKSB7XG4gICAgICAgIC8vIEV4cG9ydCBHb29nbGUgRG9jIHRvIHRleHRcbiAgICAgICAgY29uc3QgZXhwb3J0VXJsID0gYXdhaXQgdGhpcy5leHBvcnRHb29nbGVEb2MoZmlsZUlkLCAndGV4dC9wbGFpbicpO1xuICAgICAgICBjb25zdCBleHBvcnRSZXNwb25zZSA9IGF3YWl0IGZldGNoKGV4cG9ydFVybCk7XG4gICAgICAgIGNvbnRlbnQgPSBhd2FpdCBleHBvcnRSZXNwb25zZS50ZXh0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHZXQgcmF3IGNvbnRlbnQgZm9yIG90aGVyIGZpbGUgdHlwZXNcbiAgICAgICAgY29udGVudCA9IGF3YWl0IGNvbnRlbnRSZXNwb25zZS50ZXh0KCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7IG5hbWUsIGNvbnRlbnQsIG1pbWVUeXBlIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGltcG9ydGluZyBmaWxlOiAke2Vycm9yfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gaW1wb3J0IGZpbGU6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgZmlsZXMgZnJvbSBHb29nbGUgRHJpdmVcbiAgICogQHBhcmFtIHF1ZXJ5IE9wdGlvbmFsIHNlYXJjaCBxdWVyeSB0byBmaWx0ZXIgZmlsZXNcbiAgICogQHJldHVybnMgQXJyYXkgb2YgR29vZ2xlIERyaXZlIGZpbGVzXG4gICAqL1xuICBhc3luYyBsaXN0RHJpdmVGaWxlcyhxdWVyeTogc3RyaW5nID0gJycpIHtcbiAgICBpZiAoIXRoaXMuaXNBdXRoZW50aWNhdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhlbnRpY2F0ZWQgd2l0aCBHb29nbGUgRHJpdmUnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gVXNlIHRoZSBHb29nbGUgRHJpdmUgQVBJIHRvIGxpc3QgZmlsZXNcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgd2luZG93LmdhcGkuY2xpZW50LmRyaXZlLmZpbGVzLmxpc3Qoe1xuICAgICAgICBwYWdlU2l6ZTogNTAsXG4gICAgICAgIGZpZWxkczogJ2ZpbGVzKGlkLCBuYW1lLCBtaW1lVHlwZSwgbW9kaWZpZWRUaW1lLCB3ZWJWaWV3TGluayknLFxuICAgICAgICBxOiBxdWVyeSA/IHF1ZXJ5IDogJ3RyYXNoZWQgPSBmYWxzZScsXG4gICAgICAgIG9yZGVyQnk6ICdtb2RpZmllZFRpbWUgZGVzYydcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZygnR29vZ2xlIERyaXZlIGZpbGVzOicsIHJlc3BvbnNlLnJlc3VsdC5maWxlcyk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0LmZpbGVzIHx8IFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsaXN0aW5nIERyaXZlIGZpbGVzOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFJIENvbmZsaWN0IERldGVjdGlvbiBTZXJ2aWNlXG4gKiBcbiAqIFRoaXMgc2VydmljZSBpbXBsZW1lbnRzIGEgYmFzaWMgQUkgY29uZmxpY3QgZGV0ZWN0aW9uIGFsZ29yaXRobVxuICogdG8gZmxhZyBjb25mbGljdHMgYmV0d2VlbiBkb2N1bWVudHMgb3IgY29udGVudCBzZWN0aW9ucy5cbiAqIFxuICogSW4gYSBwcm9kdWN0aW9uIGVudmlyb25tZW50LCB0aGlzIHdvdWxkIGludGVncmF0ZSB3aXRoIGFuXG4gKiBhY3R1YWwgTkxQIG9yIEFJIHNlcnZpY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25mbGljdERldGVjdGlvblNlcnZpY2Uge1xuICAvKipcbiAgICogRGV0ZWN0IGNvbmZsaWN0cyBiZXR3ZWVuIGRvY3VtZW50IGNvbnRlbnQgc2VjdGlvbnNcbiAgICogQHBhcmFtIGNvbnRlbnRBIEZpcnN0IGNvbnRlbnQgc2VjdGlvblxuICAgKiBAcGFyYW0gY29udGVudEIgU2Vjb25kIGNvbnRlbnQgc2VjdGlvblxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBkZXRlY3RlZCBjb25mbGljdHNcbiAgICovXG4gIGRldGVjdENvbmZsaWN0cyhjb250ZW50QTogc3RyaW5nLCBjb250ZW50Qjogc3RyaW5nKTogQXJyYXk8e1xuICAgIHR5cGU6ICdkdXBsaWNhdGVfY29udGVudCcgfCAnY29uZmxpY3RpbmdfcGVyc3BlY3RpdmUnO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgc2VjdGlvbnM6IHN0cmluZ1tdO1xuICB9PiB7XG4gICAgY29uc3QgY29uZmxpY3RzOiBBcnJheTx7XG4gICAgICB0eXBlOiAnZHVwbGljYXRlX2NvbnRlbnQnIHwgJ2NvbmZsaWN0aW5nX3BlcnNwZWN0aXZlJztcbiAgICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgICBzZWN0aW9uczogc3RyaW5nW107XG4gICAgfT4gPSBbXTtcbiAgICBcbiAgICAvLyBUaGlzIGlzIGEgdmVyeSBiYXNpYyBpbXBsZW1lbnRhdGlvbiBmb3IgZGVtb25zdHJhdGlvbiBwdXJwb3Nlc1xuICAgIFxuICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgY29udGVudCAoZXhhY3QgbWF0Y2hlcylcbiAgICBjb25zdCBwYXJhZ3JhcGhzQSA9IGNvbnRlbnRBLnNwbGl0KCdcXG5cXG4nKTtcbiAgICBjb25zdCBwYXJhZ3JhcGhzQiA9IGNvbnRlbnRCLnNwbGl0KCdcXG5cXG4nKTtcbiAgICBcbiAgICAvLyBDb21wYXJlIHBhcmFncmFwaHMgZm9yIGV4YWN0IG1hdGNoZXMgKHNpbXVsYXRpbmcgZHVwbGljYXRlIGNvbnRlbnQgZGV0ZWN0aW9uKVxuICAgIGZvciAoY29uc3QgcGFyYUEgb2YgcGFyYWdyYXBoc0EpIHtcbiAgICAgIGlmIChwYXJhQS5sZW5ndGggPiA1MCAmJiBwYXJhZ3JhcGhzQi5pbmNsdWRlcyhwYXJhQSkpIHtcbiAgICAgICAgY29uZmxpY3RzLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdkdXBsaWNhdGVfY29udGVudCcsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdEdXBsaWNhdGUgcGFyYWdyYXBoIGRldGVjdGVkJyxcbiAgICAgICAgICBzZWN0aW9uczogW3BhcmFBXSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFNpbXVsYXRpbmcgY29uZmxpY3RpbmcgcGVyc3BlY3RpdmUgZGV0ZWN0aW9uXG4gICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIHVzZSBOTFAgdG8gZGV0ZWN0IGNvbnRyYWRpY3Rvcnkgc3RhdGVtZW50c1xuICAgIGNvbnN0IGtleXdvcmRzQSA9IHRoaXMuZXh0cmFjdEtleXdvcmRzKGNvbnRlbnRBKTtcbiAgICBjb25zdCBrZXl3b3Jkc0IgPSB0aGlzLmV4dHJhY3RLZXl3b3Jkcyhjb250ZW50Qik7XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIG9wcG9zaXRlIHNlbnRpbWVudCBrZXl3b3JkcyAodmVyeSBzaW1wbGlmaWVkIGFwcHJvYWNoKVxuICAgIGNvbnN0IG9wcG9zaXRlS2V5d29yZHMgPSBbXG4gICAgICBbJ3N1cHBvcnQnLCAnb3Bwb3NlJ10sXG4gICAgICBbJ2FncmVlJywgJ2Rpc2FncmVlJ10sXG4gICAgICBbJ2FwcHJvdmUnLCAnZGlzYXBwcm92ZSddLFxuICAgICAgWydpbmNyZWFzZScsICdkZWNyZWFzZSddLFxuICAgICAgWydwb3NpdGl2ZScsICduZWdhdGl2ZSddLFxuICAgIF07XG4gICAgXG4gICAgZm9yIChjb25zdCBbcG9zaXRpdmUsIG5lZ2F0aXZlXSBvZiBvcHBvc2l0ZUtleXdvcmRzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChrZXl3b3Jkc0EuaW5jbHVkZXMocG9zaXRpdmUpICYmIGtleXdvcmRzQi5pbmNsdWRlcyhuZWdhdGl2ZSkpIHx8XG4gICAgICAgIChrZXl3b3Jkc0EuaW5jbHVkZXMobmVnYXRpdmUpICYmIGtleXdvcmRzQi5pbmNsdWRlcyhwb3NpdGl2ZSkpXG4gICAgICApIHtcbiAgICAgICAgY29uZmxpY3RzLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdjb25mbGljdGluZ19wZXJzcGVjdGl2ZScsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBQb3RlbnRpYWxseSBjb25mbGljdGluZyBwb3NpdGlvbnM6IFwiJHtwb3NpdGl2ZX1cIiB2cyBcIiR7bmVnYXRpdmV9XCJgLFxuICAgICAgICAgIHNlY3Rpb25zOiB0aGlzLmZpbmRTZW50ZW5jZXNXaXRoS2V5d29yZHMoXG4gICAgICAgICAgICBbY29udGVudEEsIGNvbnRlbnRCXSxcbiAgICAgICAgICAgIFtwb3NpdGl2ZSwgbmVnYXRpdmVdXG4gICAgICAgICAgKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjb25mbGljdHM7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBFeHRyYWN0IGtleXdvcmRzIGZyb20gdGV4dCAoc2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbilcbiAgICogQHBhcmFtIHRleHQgVGhlIHRleHQgdG8gZXh0cmFjdCBrZXl3b3JkcyBmcm9tXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGV4dHJhY3RlZCBrZXl3b3Jkc1xuICAgKi9cbiAgcHJpdmF0ZSBleHRyYWN0S2V5d29yZHModGV4dDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uLlxuICAgIC8vIEluIGEgcmVhbCBhcHAsIHlvdSB3b3VsZCB1c2UgYSBwcm9wZXIgTkxQIGxpYnJhcnkgZm9yIGtleXdvcmQgZXh0cmFjdGlvbi5cbiAgICBjb25zdCB3b3JkcyA9IHRleHQudG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxXKy8pO1xuICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQod29yZHMuZmlsdGVyKHdvcmQgPT4gd29yZC5sZW5ndGggPiAzKSkpO1xuICB9XG4gIFxuICAvKipcbiAgICogRmluZCBzZW50ZW5jZXMgY29udGFpbmluZyBzcGVjaWZpYyBrZXl3b3Jkc1xuICAgKiBAcGFyYW0gdGV4dHMgQXJyYXkgb2YgdGV4dCBibG9ja3MgdG8gc2VhcmNoIGluXG4gICAqIEBwYXJhbSBrZXl3b3JkcyBLZXl3b3JkcyB0byBzZWFyY2ggZm9yXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIHNlbnRlbmNlcyBjb250YWluaW5nIHRoZSBrZXl3b3Jkc1xuICAgKi9cbiAgcHJpdmF0ZSBmaW5kU2VudGVuY2VzV2l0aEtleXdvcmRzKHRleHRzOiBzdHJpbmdbXSwga2V5d29yZHM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHNlbnRlbmNlczogc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICAvLyBTcGxpdCB0ZXh0cyBpbnRvIHNlbnRlbmNlcyBhbmQgZmluZCB0aG9zZSBjb250YWluaW5nIGtleXdvcmRzXG4gICAgZm9yIChjb25zdCB0ZXh0IG9mIHRleHRzKSB7XG4gICAgICBjb25zdCB0ZXh0U2VudGVuY2VzID0gdGV4dC5zcGxpdCgvWy4hP10rLykuZmlsdGVyKHMgPT4gcy50cmltKCkubGVuZ3RoID4gMCk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3Qgc2VudGVuY2Ugb2YgdGV4dFNlbnRlbmNlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleXdvcmQgb2Yga2V5d29yZHMpIHtcbiAgICAgICAgICBpZiAoc2VudGVuY2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhrZXl3b3JkLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICBzZW50ZW5jZXMucHVzaChzZW50ZW5jZS50cmltKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzZW50ZW5jZXM7XG4gIH1cbn1cblxuLy8gQ3JlYXRlIHNpbmdsZXRvbiBpbnN0YW5jZXMgZm9yIHVzZSB0aHJvdWdob3V0IHRoZSBhcHBsaWNhdGlvblxuZXhwb3J0IGNvbnN0IGdvb2dsZURyaXZlU2VydmljZSA9IG5ldyBHb29nbGVEcml2ZVNlcnZpY2UoKTtcbmV4cG9ydCBjb25zdCBjb25mbGljdERldGVjdGlvblNlcnZpY2UgPSBuZXcgQ29uZmxpY3REZXRlY3Rpb25TZXJ2aWNlKCk7XG5cbi8vIEFkZCBUeXBlU2NyaXB0IGludGVyZmFjZXMgZm9yIEdvb2dsZSBBUEkgd2luZG93cyByZWZlcmVuY2VzXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIGdhcGk6IGFueTtcbiAgICBnb29nbGU6IGFueTtcbiAgfVxufSAiXSwibmFtZXMiOlsiREVGQVVMVF9DT05GSUciLCJjbGllbnRJZCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19HT09HTEVfQ0xJRU5UX0lEIiwiYXBpS2V5IiwiTkVYVF9QVUJMSUNfR09PR0xFX0FQSV9LRVkiLCJzY29wZXMiLCJHb29nbGVEcml2ZVNlcnZpY2UiLCJpbml0aWFsaXplIiwiaW5pdGlhbGl6YXRpb25Qcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzY3JpcHQxIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwiYXN5bmMiLCJkZWZlciIsIm9ubG9hZCIsImdhcGlMb2FkZWQiLCJsb2FkR2FwaUNsaWVudCIsInRoZW4iLCJnaXNMb2FkZWQiLCJjYXRjaCIsIm9uZXJyb3IiLCJlcnJvciIsImNvbnNvbGUiLCJFcnJvciIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInNjcmlwdDIiLCJpbml0aWFsaXplVG9rZW5DbGllbnQiLCJ3aW5kb3ciLCJnYXBpIiwibG9hZCIsImNhbGxiYWNrIiwiY2xpZW50IiwiaW5pdCIsImNvbmZpZyIsImRpc2NvdmVyeURvY3MiLCJ0b2tlbkNsaWVudCIsImdvb2dsZSIsImFjY291bnRzIiwib2F1dGgyIiwiaW5pdFRva2VuQ2xpZW50IiwiY2xpZW50X2lkIiwic2NvcGUiLCJqb2luIiwidG9rZW5SZXNwb25zZSIsImFjY2Vzc1Rva2VuIiwiYWNjZXNzX3Rva2VuIiwic2V0VG9rZW4iLCJhdXRoZW50aWNhdGUiLCJyZXNwIiwiZ2V0VG9rZW4iLCJyZXF1ZXN0QWNjZXNzVG9rZW4iLCJwcm9tcHQiLCJpc0F1dGhlbnRpY2F0ZWQiLCJjcmVhdGVHb29nbGVEb2MiLCJleGlzdGluZ0RvY3MiLCJkcml2ZSIsImZpbGVzIiwibGlzdCIsInEiLCJpZCIsImZpZWxkcyIsInJlc3VsdCIsImxlbmd0aCIsImxvZyIsIndlYlZpZXdMaW5rIiwicmVzcG9uc2UiLCJjcmVhdGUiLCJyZXNvdXJjZSIsIm5hbWUiLCJ0aXRsZSIsIm1pbWVUeXBlIiwiZGVzY3JpcHRpb24iLCJ0eXBlIiwiY29tbWl0dGVlIiwiY291bnRyeSIsInByb3BlcnRpZXMiLCJtdW5Db25uZWN0RG9jSWQiLCJkb2N1bWVudFR5cGUiLCJjcmVhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJsYXN0U3luY2VkQXQiLCJjYWNoZUtleSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwiZ29vZ2xlRG9jSWQiLCJsYXN0U3luY2VkIiwibWV0YWRhdGEiLCJjYWNoZUVycm9yIiwid2FybiIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJnZXRHb29nbGVEb2MiLCJjYWNoZWREYXRhIiwiZ2V0SXRlbSIsInBhcnNlZCIsInBhcnNlIiwiY2FjaGVBZ2UiLCJub3ciLCJnZXRUaW1lIiwiZ2V0IiwiZmlsZUlkIiwidXBkYXRlR29vZ2xlRG9jIiwiY29udGVudCIsInVwZGF0ZSIsImxhc3RVcGRhdGVkIiwiZXhwb3J0R29vZ2xlRG9jIiwiZmV0Y2giLCJlbmNvZGVVUklDb21wb25lbnQiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsIm9rIiwic3RhdHVzVGV4dCIsImJsb2IiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJ3YXRjaEdvb2dsZURvYyIsImNoZWNrSW50ZXJ2YWwiLCJsYXN0TW9kaWZpZWQiLCJpbnRlcnZhbElkIiwic2V0SW50ZXJ2YWwiLCJkb2MiLCJtb2RpZmllZFRpbWUiLCJkb2N1bWVudElkIiwiY2xlYXJJbnRlcnZhbCIsImltcG9ydEZpbGUiLCJtZXRhZGF0YVJlc3BvbnNlIiwiY29udGVudFJlc3BvbnNlIiwiZXhwb3J0VXJsIiwiZXhwb3J0UmVzcG9uc2UiLCJ0ZXh0IiwibGlzdERyaXZlRmlsZXMiLCJxdWVyeSIsInBhZ2VTaXplIiwib3JkZXJCeSIsImNvbnN0cnVjdG9yIiwiQ29uZmxpY3REZXRlY3Rpb25TZXJ2aWNlIiwiZGV0ZWN0Q29uZmxpY3RzIiwiY29udGVudEEiLCJjb250ZW50QiIsImNvbmZsaWN0cyIsInBhcmFncmFwaHNBIiwic3BsaXQiLCJwYXJhZ3JhcGhzQiIsInBhcmFBIiwiaW5jbHVkZXMiLCJwdXNoIiwic2VjdGlvbnMiLCJrZXl3b3Jkc0EiLCJleHRyYWN0S2V5d29yZHMiLCJrZXl3b3Jkc0IiLCJvcHBvc2l0ZUtleXdvcmRzIiwicG9zaXRpdmUiLCJuZWdhdGl2ZSIsImZpbmRTZW50ZW5jZXNXaXRoS2V5d29yZHMiLCJ3b3JkcyIsInRvTG93ZXJDYXNlIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwiZmlsdGVyIiwid29yZCIsInRleHRzIiwia2V5d29yZHMiLCJzZW50ZW5jZXMiLCJ0ZXh0U2VudGVuY2VzIiwicyIsInRyaW0iLCJzZW50ZW5jZSIsImtleXdvcmQiLCJnb29nbGVEcml2ZVNlcnZpY2UiLCJjb25mbGljdERldGVjdGlvblNlcnZpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/googleDrive.ts\n"));

/***/ })

});