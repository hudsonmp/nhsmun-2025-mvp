"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/googleDrive.ts":
/*!****************************!*\
  !*** ./lib/googleDrive.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConflictDetectionService: function() { return /* binding */ ConflictDetectionService; },\n/* harmony export */   GoogleDriveService: function() { return /* binding */ GoogleDriveService; },\n/* harmony export */   conflictDetectionService: function() { return /* binding */ conflictDetectionService; },\n/* harmony export */   googleDriveService: function() { return /* binding */ googleDriveService; }\n/* harmony export */ });\n/**\n * Google Drive API Integration Service\n * \n * This service handles the integration with Google Drive API for document management\n * and real-time collaboration.\n * \n * Google Cloud Project Setup Instructions:\n * 1. Create a new project in Google Cloud Console (https://console.cloud.google.com/)\n * 2. Enable the Google Drive API\n * 3. Configure OAuth consent screen\n *    - User Type: External\n *    - Application name: MUN Connect\n *    - Authorized domains: your-domain.com\n *    - Developer contact information: your-email@example.com\n * 4. Create OAuth 2.0 credentials\n *    - Application type: Web application\n *    - Name: MUN Connect Web Client\n *    - Authorized JavaScript origins: http://localhost:3000, https://your-domain.com\n *    - Authorized redirect URIs: http://localhost:3000/api/auth/callback/google, https://your-domain.com/api/auth/callback/google\n * 5. Add the following environment variables to your .env.local file:\n *    - GOOGLE_CLIENT_ID=your-client-id\n *    - GOOGLE_CLIENT_SECRET=your-client-secret\n *    - GOOGLE_API_KEY=your-api-key (for public API access)\n */ // Default configuration - these values should be replaced with environment variables\nconst DEFAULT_CONFIG = {\n    clientId: \"913358736520-5biusol4f5ead6t86d7rv94rd0ar3gkn.apps.googleusercontent.com\" || 0,\n    apiKey: \"AIzaSyB-pZ0FV758VUs_pIZ0Ck2iq5Wx0FDJCxw\" || 0,\n    scopes: [\n        \"https://www.googleapis.com/auth/drive.file\",\n        \"https://www.googleapis.com/auth/drive.appdata\"\n    ]\n};\n// Google Drive API Service\nclass GoogleDriveService {\n    /**\n   * Initialize the Google Drive API\n   * This loads the required libraries and initializes the API client\n   */ async initialize() {\n        if (this.initializationPromise) {\n            return this.initializationPromise;\n        }\n        this.initializationPromise = new Promise((resolve, reject)=>{\n            try {\n                // Load the Google API client library\n                const script1 = document.createElement(\"script\");\n                script1.src = \"https://apis.google.com/js/api.js\";\n                script1.async = true;\n                script1.defer = true;\n                script1.onload = ()=>{\n                    this.gapiLoaded = true;\n                    this.loadGapiClient().then(()=>{\n                        if (this.gisLoaded) resolve();\n                    }).catch(reject);\n                };\n                script1.onerror = (error)=>{\n                    console.error(\"Failed to load Google API client:\", error);\n                    reject(new Error(\"Failed to load Google API client\"));\n                };\n                document.body.appendChild(script1);\n                // Load the Google Identity Services library\n                const script2 = document.createElement(\"script\");\n                script2.src = \"https://accounts.google.com/gsi/client\";\n                script2.async = true;\n                script2.defer = true;\n                script2.onload = ()=>{\n                    this.gisLoaded = true;\n                    this.initializeTokenClient();\n                    if (this.gapiLoaded) resolve();\n                };\n                script2.onerror = (error)=>{\n                    console.error(\"Failed to load Google Identity Services:\", error);\n                    reject(new Error(\"Failed to load Google Identity Services\"));\n                };\n                document.body.appendChild(script2);\n            } catch (error) {\n                console.error(\"Error initializing Google Drive API:\", error);\n                reject(new Error(\"Error initializing Google Drive API: \".concat(error)));\n            }\n        });\n        return this.initializationPromise;\n    }\n    /**\n   * Load the Google API client library\n   */ async loadGapiClient() {\n        return new Promise((resolve, reject)=>{\n            try {\n                window.gapi.load(\"client\", {\n                    callback: async ()=>{\n                        try {\n                            await window.gapi.client.init({\n                                apiKey: this.config.apiKey,\n                                discoveryDocs: [\n                                    \"https://www.googleapis.com/discovery/v1/apis/drive/v3/rest\"\n                                ]\n                            });\n                            resolve();\n                        } catch (error) {\n                            reject(\"Error initializing GAPI client: \".concat(error));\n                        }\n                    },\n                    onerror: (error)=>reject(\"Error loading GAPI client: \".concat(error))\n                });\n            } catch (error) {\n                reject(\"Failed to load GAPI client: \".concat(error));\n            }\n        });\n    }\n    /**\n   * Initialize the Google Identity Services token client\n   */ initializeTokenClient() {\n        this.tokenClient = window.google.accounts.oauth2.initTokenClient({\n            client_id: this.config.clientId,\n            scope: this.config.scopes.join(\" \"),\n            callback: (tokenResponse)=>{\n                if (tokenResponse.error) {\n                    console.error(\"Error getting access token: \".concat(tokenResponse.error));\n                    return;\n                }\n                this.accessToken = tokenResponse.access_token;\n                window.gapi.client.setToken(tokenResponse);\n            }\n        });\n    }\n    /**\n   * Authenticate the user and request access to Google Drive\n   */ async authenticate() {\n        if (!this.initializationPromise) {\n            await this.initialize();\n        }\n        return new Promise((resolve)=>{\n            if (!this.tokenClient) {\n                console.error(\"Token client not initialized. Attempting to reinitialize...\");\n                this.initializeTokenClient();\n                if (!this.tokenClient) {\n                    throw new Error(\"Failed to initialize token client\");\n                }\n            }\n            try {\n                this.tokenClient.callback = (resp)=>{\n                    if (resp.error) {\n                        console.error(\"Error during authentication:\", resp.error);\n                        resolve(false);\n                        return;\n                    }\n                    this.accessToken = resp.access_token;\n                    window.gapi.client.setToken({\n                        access_token: this.accessToken\n                    });\n                    resolve(true);\n                };\n                if (!window.gapi.client.getToken()) {\n                    // Request an access token\n                    this.tokenClient.requestAccessToken({\n                        prompt: \"consent\"\n                    });\n                } else {\n                    // Already have an access token\n                    this.accessToken = window.gapi.client.getToken().access_token;\n                    resolve(true);\n                }\n            } catch (error) {\n                console.error(\"Error authenticating:\", error);\n                resolve(false);\n            }\n        });\n    }\n    /**\n   * Check if the user is authenticated\n   */ isAuthenticated() {\n        return this.accessToken !== null;\n    }\n    /**\n   * Create a new Google Doc for a document\n   * @param document The document to create a Google Doc for\n   * @returns The ID of the created Google Doc\n   */ async createGoogleDoc(document1) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            const response = await window.gapi.client.drive.files.create({\n                resource: {\n                    name: document1.title,\n                    mimeType: \"application/vnd.google-apps.document\",\n                    description: \"MUN Connect document: \".concat(document1.type, \" for \").concat(document1.committee, \" - \").concat(document1.country),\n                    properties: {\n                        munConnectDocId: document1.id,\n                        documentType: document1.type,\n                        committee: document1.committee,\n                        country: document1.country\n                    }\n                },\n                fields: \"id,webViewLink\"\n            });\n            return response.result.id;\n        } catch (error) {\n            console.error(\"Error creating Google Doc: \".concat(error));\n            throw new Error(\"Failed to create Google Doc: \".concat(error));\n        }\n    }\n    /**\n   * Get a Google Doc by its ID\n   * @param googleDocId The ID of the Google Doc to get\n   * @returns The Google Doc metadata\n   */ async getGoogleDoc(googleDocId) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            const response = await window.gapi.client.drive.files.get({\n                fileId: googleDocId,\n                fields: \"id,name,webViewLink,modifiedTime,capabilities\"\n            });\n            return response.result;\n        } catch (error) {\n            console.error(\"Error getting Google Doc: \".concat(error));\n            throw new Error(\"Failed to get Google Doc: \".concat(error));\n        }\n    }\n    /**\n   * Update a Google Doc's content\n   * @param googleDocId The ID of the Google Doc to update\n   * @param content The new content of the Google Doc\n   */ async updateGoogleDoc(googleDocId, content) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            // This is a simplified version. In a real implementation,\n            // you would use the Google Docs API to update the document content.\n            // For simplicity, we're just updating the document's metadata here.\n            await window.gapi.client.drive.files.update({\n                fileId: googleDocId,\n                resource: {\n                    properties: {\n                        lastUpdated: new Date().toISOString()\n                    }\n                }\n            });\n        } catch (error) {\n            console.error(\"Error updating Google Doc: \".concat(error));\n            throw new Error(\"Failed to update Google Doc: \".concat(error));\n        }\n    }\n    /**\n   * Export a Google Doc to a specific format (PDF, DOCX)\n   * @param googleDocId The ID of the Google Doc to export\n   * @param mimeType The mime type to export to (e.g., 'application/pdf')\n   * @returns A URL to download the exported file\n   */ async exportGoogleDoc(googleDocId, mimeType) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            const response = await fetch(\"https://www.googleapis.com/drive/v3/files/\".concat(googleDocId, \"/export?mimeType=\").concat(encodeURIComponent(mimeType)), {\n                headers: {\n                    Authorization: \"Bearer \".concat(this.accessToken)\n                }\n            });\n            if (!response.ok) {\n                throw new Error(\"Failed to export Google Doc: \".concat(response.statusText));\n            }\n            const blob = await response.blob();\n            return URL.createObjectURL(blob);\n        } catch (error) {\n            console.error(\"Error exporting Google Doc: \".concat(error));\n            throw new Error(\"Failed to export Google Doc: \".concat(error));\n        }\n    }\n    /**\n   * Watch for changes to a Google Doc\n   * This is a placeholder for real-time sync functionality.\n   * In a production environment, you would use the Google Drive API's\n   * watch method or establish a WebSocket connection.\n   * \n   * @param googleDocId The ID of the Google Doc to watch\n   * @param callback The callback to call when the Google Doc changes\n   * @returns A function to stop watching for changes\n   */ watchGoogleDoc(googleDocId, callback) {\n        // This is a placeholder. In a real implementation, you would use the Google Drive API's\n        // changes.watch method or establish a WebSocket connection.\n        const checkInterval = 5000; // Check every 5 seconds\n        let lastModified = null;\n        const intervalId = setInterval(async ()=>{\n            try {\n                if (!this.isAuthenticated()) {\n                    console.warn(\"Not authenticated with Google Drive\");\n                    return;\n                }\n                const doc = await this.getGoogleDoc(googleDocId);\n                if (lastModified !== null && doc.modifiedTime !== lastModified) {\n                    // Document has changed\n                    callback({\n                        documentId: googleDocId,\n                        modifiedTime: doc.modifiedTime\n                    });\n                }\n                lastModified = doc.modifiedTime;\n            } catch (error) {\n                console.error(\"Error checking for Google Doc changes: \".concat(error));\n            }\n        }, checkInterval);\n        // Return a function to stop watching for changes\n        return ()=>clearInterval(intervalId);\n    }\n    /**\n   * Import a file from Google Drive\n   * @param fileId The ID of the file to import\n   * @returns The imported file data\n   */ async importFile(fileId) {\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            // Get file metadata\n            const metadataResponse = await window.gapi.client.drive.files.get({\n                fileId,\n                fields: \"name,mimeType\"\n            });\n            const { name, mimeType } = metadataResponse.result;\n            // Get file content\n            const contentResponse = await fetch(\"https://www.googleapis.com/drive/v3/files/\".concat(fileId, \"?alt=media\"), {\n                headers: {\n                    Authorization: \"Bearer \".concat(this.accessToken)\n                }\n            });\n            if (!contentResponse.ok) {\n                throw new Error(\"Failed to get file content: \".concat(contentResponse.statusText));\n            }\n            let content = \"\";\n            if (mimeType === \"application/vnd.google-apps.document\") {\n                // Export Google Doc to text\n                const exportUrl = await this.exportGoogleDoc(fileId, \"text/plain\");\n                const exportResponse = await fetch(exportUrl);\n                content = await exportResponse.text();\n            } else {\n                // Get raw content for other file types\n                content = await contentResponse.text();\n            }\n            return {\n                name,\n                content,\n                mimeType\n            };\n        } catch (error) {\n            console.error(\"Error importing file: \".concat(error));\n            throw new Error(\"Failed to import file: \".concat(error));\n        }\n    }\n    /**\n   * List files from Google Drive\n   * @param query Optional search query to filter files\n   * @returns Array of Google Drive files\n   */ async listDriveFiles() {\n        let query = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n        if (!this.isAuthenticated()) {\n            throw new Error(\"Not authenticated with Google Drive\");\n        }\n        try {\n            // Use the Google Drive API to list files\n            const response = await window.gapi.client.drive.files.list({\n                pageSize: 50,\n                fields: \"files(id, name, mimeType, modifiedTime, webViewLink)\",\n                q: query ? query : \"trashed = false\",\n                orderBy: \"modifiedTime desc\"\n            });\n            console.log(\"Google Drive files:\", response.result.files);\n            return response.result.files || [];\n        } catch (error) {\n            console.error(\"Error listing Drive files:\", error);\n            throw error;\n        }\n    }\n    constructor(config = {}){\n        this.gapiLoaded = false;\n        this.gisLoaded = false;\n        this.tokenClient = null;\n        this.accessToken = null;\n        this.initializationPromise = null;\n        this.config = {\n            ...DEFAULT_CONFIG,\n            ...config\n        };\n        if (!this.config.clientId) {\n            throw new Error(\"Google Client ID is required but not provided\");\n        }\n        if (!this.config.apiKey) {\n            throw new Error(\"Google API Key is required but not provided\");\n        }\n    }\n}\n/**\n * AI Conflict Detection Service\n * \n * This service implements a basic AI conflict detection algorithm\n * to flag conflicts between documents or content sections.\n * \n * In a production environment, this would integrate with an\n * actual NLP or AI service.\n */ class ConflictDetectionService {\n    /**\n   * Detect conflicts between document content sections\n   * @param contentA First content section\n   * @param contentB Second content section\n   * @returns Array of detected conflicts\n   */ detectConflicts(contentA, contentB) {\n        const conflicts = [];\n        // This is a very basic implementation for demonstration purposes\n        // Check for duplicate content (exact matches)\n        const paragraphsA = contentA.split(\"\\n\\n\");\n        const paragraphsB = contentB.split(\"\\n\\n\");\n        // Compare paragraphs for exact matches (simulating duplicate content detection)\n        for (const paraA of paragraphsA){\n            if (paraA.length > 50 && paragraphsB.includes(paraA)) {\n                conflicts.push({\n                    type: \"duplicate_content\",\n                    description: \"Duplicate paragraph detected\",\n                    sections: [\n                        paraA\n                    ]\n                });\n            }\n        }\n        // Simulating conflicting perspective detection\n        // In a real implementation, this would use NLP to detect contradictory statements\n        const keywordsA = this.extractKeywords(contentA);\n        const keywordsB = this.extractKeywords(contentB);\n        // Check for opposite sentiment keywords (very simplified approach)\n        const oppositeKeywords = [\n            [\n                \"support\",\n                \"oppose\"\n            ],\n            [\n                \"agree\",\n                \"disagree\"\n            ],\n            [\n                \"approve\",\n                \"disapprove\"\n            ],\n            [\n                \"increase\",\n                \"decrease\"\n            ],\n            [\n                \"positive\",\n                \"negative\"\n            ]\n        ];\n        for (const [positive, negative] of oppositeKeywords){\n            if (keywordsA.includes(positive) && keywordsB.includes(negative) || keywordsA.includes(negative) && keywordsB.includes(positive)) {\n                conflicts.push({\n                    type: \"conflicting_perspective\",\n                    description: 'Potentially conflicting positions: \"'.concat(positive, '\" vs \"').concat(negative, '\"'),\n                    sections: this.findSentencesWithKeywords([\n                        contentA,\n                        contentB\n                    ], [\n                        positive,\n                        negative\n                    ])\n                });\n            }\n        }\n        return conflicts;\n    }\n    /**\n   * Extract keywords from text (simplified implementation)\n   * @param text The text to extract keywords from\n   * @returns Array of extracted keywords\n   */ extractKeywords(text) {\n        // This is a simplified implementation.\n        // In a real app, you would use a proper NLP library for keyword extraction.\n        const words = text.toLowerCase().split(/\\W+/);\n        return Array.from(new Set(words.filter((word)=>word.length > 3)));\n    }\n    /**\n   * Find sentences containing specific keywords\n   * @param texts Array of text blocks to search in\n   * @param keywords Keywords to search for\n   * @returns Array of sentences containing the keywords\n   */ findSentencesWithKeywords(texts, keywords) {\n        const sentences = [];\n        // Split texts into sentences and find those containing keywords\n        for (const text of texts){\n            const textSentences = text.split(/[.!?]+/).filter((s)=>s.trim().length > 0);\n            for (const sentence of textSentences){\n                for (const keyword of keywords){\n                    if (sentence.toLowerCase().includes(keyword.toLowerCase())) {\n                        sentences.push(sentence.trim());\n                        break;\n                    }\n                }\n            }\n        }\n        return sentences;\n    }\n}\n// Create singleton instances for use throughout the application\nconst googleDriveService = new GoogleDriveService();\nconst conflictDetectionService = new ConflictDetectionService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9nb29nbGVEcml2ZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBdUJDLEdBV0QscUZBQXFGO0FBQ3JGLE1BQU1BLGlCQUFvQztJQUN4Q0MsVUFBVUMsMEVBQXdDLElBQUk7SUFDdERHLFFBQVFILHlDQUFzQyxJQUFJO0lBQ2xESyxRQUFRO1FBQ047UUFDQTtLQUNEO0FBQ0g7QUFFQSwyQkFBMkI7QUFDcEIsTUFBTUM7SUFrQlg7OztHQUdDLEdBQ0QsTUFBTUMsYUFBNEI7UUFDaEMsSUFBSSxJQUFJLENBQUNDLHFCQUFxQixFQUFFO1lBQzlCLE9BQU8sSUFBSSxDQUFDQSxxQkFBcUI7UUFDbkM7UUFFQSxJQUFJLENBQUNBLHFCQUFxQixHQUFHLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDakQsSUFBSTtnQkFDRixxQ0FBcUM7Z0JBQ3JDLE1BQU1DLFVBQVVDLFNBQVNDLGFBQWEsQ0FBQztnQkFDdkNGLFFBQVFHLEdBQUcsR0FBRztnQkFDZEgsUUFBUUksS0FBSyxHQUFHO2dCQUNoQkosUUFBUUssS0FBSyxHQUFHO2dCQUNoQkwsUUFBUU0sTUFBTSxHQUFHO29CQUNmLElBQUksQ0FBQ0MsVUFBVSxHQUFHO29CQUNsQixJQUFJLENBQUNDLGNBQWMsR0FBR0MsSUFBSSxDQUFDO3dCQUN6QixJQUFJLElBQUksQ0FBQ0MsU0FBUyxFQUFFWjtvQkFDdEIsR0FBR2EsS0FBSyxDQUFDWjtnQkFDWDtnQkFDQUMsUUFBUVksT0FBTyxHQUFHLENBQUNDO29CQUNqQkMsUUFBUUQsS0FBSyxDQUFDLHFDQUFxQ0E7b0JBQ25EZCxPQUFPLElBQUlnQixNQUFNO2dCQUNuQjtnQkFDQWQsU0FBU2UsSUFBSSxDQUFDQyxXQUFXLENBQUNqQjtnQkFFMUIsNENBQTRDO2dCQUM1QyxNQUFNa0IsVUFBVWpCLFNBQVNDLGFBQWEsQ0FBQztnQkFDdkNnQixRQUFRZixHQUFHLEdBQUc7Z0JBQ2RlLFFB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Q0Y7WUFDRjtRQUNGO1FBRUEsT0FBT0g7SUFDVDtBQUNGO0FBRUEsZ0VBQWdFO0FBQ3pELE1BQU1NLHFCQUFxQixJQUFJdEoscUJBQXFCO0FBQ3BELE1BQU11SiwyQkFBMkIsSUFBSXBDLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvZ29vZ2xlRHJpdmUudHM/NTc1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdvb2dsZSBEcml2ZSBBUEkgSW50ZWdyYXRpb24gU2VydmljZVxuICogXG4gKiBUaGlzIHNlcnZpY2UgaGFuZGxlcyB0aGUgaW50ZWdyYXRpb24gd2l0aCBHb29nbGUgRHJpdmUgQVBJIGZvciBkb2N1bWVudCBtYW5hZ2VtZW50XG4gKiBhbmQgcmVhbC10aW1lIGNvbGxhYm9yYXRpb24uXG4gKiBcbiAqIEdvb2dsZSBDbG91ZCBQcm9qZWN0IFNldHVwIEluc3RydWN0aW9uczpcbiAqIDEuIENyZWF0ZSBhIG5ldyBwcm9qZWN0IGluIEdvb2dsZSBDbG91ZCBDb25zb2xlIChodHRwczovL2NvbnNvbGUuY2xvdWQuZ29vZ2xlLmNvbS8pXG4gKiAyLiBFbmFibGUgdGhlIEdvb2dsZSBEcml2ZSBBUElcbiAqIDMuIENvbmZpZ3VyZSBPQXV0aCBjb25zZW50IHNjcmVlblxuICogICAgLSBVc2VyIFR5cGU6IEV4dGVybmFsXG4gKiAgICAtIEFwcGxpY2F0aW9uIG5hbWU6IE1VTiBDb25uZWN0XG4gKiAgICAtIEF1dGhvcml6ZWQgZG9tYWluczogeW91ci1kb21haW4uY29tXG4gKiAgICAtIERldmVsb3BlciBjb250YWN0IGluZm9ybWF0aW9uOiB5b3VyLWVtYWlsQGV4YW1wbGUuY29tXG4gKiA0LiBDcmVhdGUgT0F1dGggMi4wIGNyZWRlbnRpYWxzXG4gKiAgICAtIEFwcGxpY2F0aW9uIHR5cGU6IFdlYiBhcHBsaWNhdGlvblxuICogICAgLSBOYW1lOiBNVU4gQ29ubmVjdCBXZWIgQ2xpZW50XG4gKiAgICAtIEF1dGhvcml6ZWQgSmF2YVNjcmlwdCBvcmlnaW5zOiBodHRwOi8vbG9jYWxob3N0OjMwMDAsIGh0dHBzOi8veW91ci1kb21haW4uY29tXG4gKiAgICAtIEF1dGhvcml6ZWQgcmVkaXJlY3QgVVJJczogaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoL2NhbGxiYWNrL2dvb2dsZSwgaHR0cHM6Ly95b3VyLWRvbWFpbi5jb20vYXBpL2F1dGgvY2FsbGJhY2svZ29vZ2xlXG4gKiA1LiBBZGQgdGhlIGZvbGxvd2luZyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8geW91ciAuZW52LmxvY2FsIGZpbGU6XG4gKiAgICAtIEdPT0dMRV9DTElFTlRfSUQ9eW91ci1jbGllbnQtaWRcbiAqICAgIC0gR09PR0xFX0NMSUVOVF9TRUNSRVQ9eW91ci1jbGllbnQtc2VjcmV0XG4gKiAgICAtIEdPT0dMRV9BUElfS0VZPXlvdXItYXBpLWtleSAoZm9yIHB1YmxpYyBBUEkgYWNjZXNzKVxuICovXG5cbmltcG9ydCB7IERvY3VtZW50IH0gZnJvbSAnLi9kb2N1bWVudCc7XG5cbi8vIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgR29vZ2xlIERyaXZlIEFQSVxuaW50ZXJmYWNlIEdvb2dsZURyaXZlQ29uZmlnIHtcbiAgY2xpZW50SWQ6IHN0cmluZztcbiAgYXBpS2V5OiBzdHJpbmc7XG4gIHNjb3Blczogc3RyaW5nW107XG59XG5cbi8vIERlZmF1bHQgY29uZmlndXJhdGlvbiAtIHRoZXNlIHZhbHVlcyBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbmNvbnN0IERFRkFVTFRfQ09ORklHOiBHb29nbGVEcml2ZUNvbmZpZyA9IHtcbiAgY2xpZW50SWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0dPT0dMRV9DTElFTlRfSUQgfHwgJycsXG4gIGFwaUtleTogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX0FQSV9LRVkgfHwgJycsXG4gIHNjb3BlczogW1xuICAgICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2RyaXZlLmZpbGUnLFxuICAgICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2RyaXZlLmFwcGRhdGEnLFxuICBdLFxufTtcblxuLy8gR29vZ2xlIERyaXZlIEFQSSBTZXJ2aWNlXG5leHBvcnQgY2xhc3MgR29vZ2xlRHJpdmVTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBnYXBpTG9hZGVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgZ2lzTG9hZGVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgdG9rZW5DbGllbnQ6IGFueSA9IG51bGw7XG4gIHByaXZhdGUgYWNjZXNzVG9rZW46IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGNvbmZpZzogR29vZ2xlRHJpdmVDb25maWc7XG4gIHByaXZhdGUgaW5pdGlhbGl6YXRpb25Qcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XG4gIFxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFBhcnRpYWw8R29vZ2xlRHJpdmVDb25maWc+ID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHsgLi4uREVGQVVMVF9DT05GSUcsIC4uLmNvbmZpZyB9O1xuICAgIGlmICghdGhpcy5jb25maWcuY2xpZW50SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR29vZ2xlIENsaWVudCBJRCBpcyByZXF1aXJlZCBidXQgbm90IHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb25maWcuYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dvb2dsZSBBUEkgS2V5IGlzIHJlcXVpcmVkIGJ1dCBub3QgcHJvdmlkZWQnKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBHb29nbGUgRHJpdmUgQVBJXG4gICAqIFRoaXMgbG9hZHMgdGhlIHJlcXVpcmVkIGxpYnJhcmllcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIEFQSSBjbGllbnRcbiAgICovXG4gIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6YXRpb25Qcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsaXphdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBMb2FkIHRoZSBHb29nbGUgQVBJIGNsaWVudCBsaWJyYXJ5XG4gICAgICAgIGNvbnN0IHNjcmlwdDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0MS5zcmMgPSAnaHR0cHM6Ly9hcGlzLmdvb2dsZS5jb20vanMvYXBpLmpzJztcbiAgICAgICAgc2NyaXB0MS5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdDEuZGVmZXIgPSB0cnVlO1xuICAgICAgICBzY3JpcHQxLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmdhcGlMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMubG9hZEdhcGlDbGllbnQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdpc0xvYWRlZCkgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIHNjcmlwdDEub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIEdvb2dsZSBBUEkgY2xpZW50OicsIGVycm9yKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBHb29nbGUgQVBJIGNsaWVudCcpKTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQxKTtcbiAgICAgICAgXG4gICAgICAgIC8vIExvYWQgdGhlIEdvb2dsZSBJZGVudGl0eSBTZXJ2aWNlcyBsaWJyYXJ5XG4gICAgICAgIGNvbnN0IHNjcmlwdDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0Mi5zcmMgPSAnaHR0cHM6Ly9hY2NvdW50cy5nb29nbGUuY29tL2dzaS9jbGllbnQnO1xuICAgICAgICBzY3JpcHQyLmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0Mi5kZWZlciA9IHRydWU7XG4gICAgICAgIHNjcmlwdDIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZ2lzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemVUb2tlbkNsaWVudCgpO1xuICAgICAgICAgIGlmICh0aGlzLmdhcGlMb2FkZWQpIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2NyaXB0Mi5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgR29vZ2xlIElkZW50aXR5IFNlcnZpY2VzOicsIGVycm9yKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBHb29nbGUgSWRlbnRpdHkgU2VydmljZXMnKSk7XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0Mik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgR29vZ2xlIERyaXZlIEFQSTonLCBlcnJvcik7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEVycm9yIGluaXRpYWxpemluZyBHb29nbGUgRHJpdmUgQVBJOiAke2Vycm9yfWApKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmluaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIExvYWQgdGhlIEdvb2dsZSBBUEkgY2xpZW50IGxpYnJhcnlcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgbG9hZEdhcGlDbGllbnQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdpbmRvdy5nYXBpLmxvYWQoJ2NsaWVudCcsIHtcbiAgICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgd2luZG93LmdhcGkuY2xpZW50LmluaXQoe1xuICAgICAgICAgICAgICAgIGFwaUtleTogdGhpcy5jb25maWcuYXBpS2V5LFxuICAgICAgICAgICAgICAgIGRpc2NvdmVyeURvY3M6IFsnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vZGlzY292ZXJ5L3YxL2FwaXMvZHJpdmUvdjMvcmVzdCddLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGBFcnJvciBpbml0aWFsaXppbmcgR0FQSSBjbGllbnQ6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbmVycm9yOiAoZXJyb3I6IGFueSkgPT4gcmVqZWN0KGBFcnJvciBsb2FkaW5nIEdBUEkgY2xpZW50OiAke2Vycm9yfWApLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChgRmFpbGVkIHRvIGxvYWQgR0FQSSBjbGllbnQ6ICR7ZXJyb3J9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBHb29nbGUgSWRlbnRpdHkgU2VydmljZXMgdG9rZW4gY2xpZW50XG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVUb2tlbkNsaWVudCgpOiB2b2lkIHtcbiAgICB0aGlzLnRva2VuQ2xpZW50ID0gd2luZG93Lmdvb2dsZS5hY2NvdW50cy5vYXV0aDIuaW5pdFRva2VuQ2xpZW50KHtcbiAgICAgIGNsaWVudF9pZDogdGhpcy5jb25maWcuY2xpZW50SWQsXG4gICAgICBzY29wZTogdGhpcy5jb25maWcuc2NvcGVzLmpvaW4oJyAnKSxcbiAgICAgIGNhbGxiYWNrOiAodG9rZW5SZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgIGlmICh0b2tlblJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2V0dGluZyBhY2Nlc3MgdG9rZW46ICR7dG9rZW5SZXNwb25zZS5lcnJvcn1gKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHRva2VuUmVzcG9uc2UuYWNjZXNzX3Rva2VuO1xuICAgICAgICB3aW5kb3cuZ2FwaS5jbGllbnQuc2V0VG9rZW4odG9rZW5SZXNwb25zZSk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogQXV0aGVudGljYXRlIHRoZSB1c2VyIGFuZCByZXF1ZXN0IGFjY2VzcyB0byBHb29nbGUgRHJpdmVcbiAgICovXG4gIGFzeW5jIGF1dGhlbnRpY2F0ZSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6YXRpb25Qcm9taXNlKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGlmICghdGhpcy50b2tlbkNsaWVudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUb2tlbiBjbGllbnQgbm90IGluaXRpYWxpemVkLiBBdHRlbXB0aW5nIHRvIHJlaW5pdGlhbGl6ZS4uLicpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVUb2tlbkNsaWVudCgpO1xuICAgICAgICBpZiAoIXRoaXMudG9rZW5DbGllbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIHRva2VuIGNsaWVudCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMudG9rZW5DbGllbnQuY2FsbGJhY2sgPSAocmVzcDogYW55KSA9PiB7XG4gICAgICAgICAgaWYgKHJlc3AuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBhdXRoZW50aWNhdGlvbjonLCByZXNwLmVycm9yKTtcbiAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gcmVzcC5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgd2luZG93LmdhcGkuY2xpZW50LnNldFRva2VuKHsgYWNjZXNzX3Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuIH0pO1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBpZiAoIXdpbmRvdy5nYXBpLmNsaWVudC5nZXRUb2tlbigpKSB7XG4gICAgICAgICAgLy8gUmVxdWVzdCBhbiBhY2Nlc3MgdG9rZW5cbiAgICAgICAgICB0aGlzLnRva2VuQ2xpZW50LnJlcXVlc3RBY2Nlc3NUb2tlbih7IHByb21wdDogJ2NvbnNlbnQnIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFscmVhZHkgaGF2ZSBhbiBhY2Nlc3MgdG9rZW5cbiAgICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gd2luZG93LmdhcGkuY2xpZW50LmdldFRva2VuKCkuYWNjZXNzX3Rva2VuO1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGF1dGhlbnRpY2F0aW5nOicsIGVycm9yKTtcbiAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgdXNlciBpcyBhdXRoZW50aWNhdGVkXG4gICAqL1xuICBpc0F1dGhlbnRpY2F0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYWNjZXNzVG9rZW4gIT09IG51bGw7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgR29vZ2xlIERvYyBmb3IgYSBkb2N1bWVudFxuICAgKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIGNyZWF0ZSBhIEdvb2dsZSBEb2MgZm9yXG4gICAqIEByZXR1cm5zIFRoZSBJRCBvZiB0aGUgY3JlYXRlZCBHb29nbGUgRG9jXG4gICAqL1xuICBhc3luYyBjcmVhdGVHb29nbGVEb2MoZG9jdW1lbnQ6IERvY3VtZW50KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuaXNBdXRoZW50aWNhdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhlbnRpY2F0ZWQgd2l0aCBHb29nbGUgRHJpdmUnKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgd2luZG93LmdhcGkuY2xpZW50LmRyaXZlLmZpbGVzLmNyZWF0ZSh7XG4gICAgICAgIHJlc291cmNlOiB7XG4gICAgICAgICAgbmFtZTogZG9jdW1lbnQudGl0bGUsXG4gICAgICAgICAgbWltZVR5cGU6ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWFwcHMuZG9jdW1lbnQnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgTVVOIENvbm5lY3QgZG9jdW1lbnQ6ICR7ZG9jdW1lbnQudHlwZX0gZm9yICR7ZG9jdW1lbnQuY29tbWl0dGVlfSAtICR7ZG9jdW1lbnQuY291bnRyeX1gLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIG11bkNvbm5lY3REb2NJZDogZG9jdW1lbnQuaWQsXG4gICAgICAgICAgICBkb2N1bWVudFR5cGU6IGRvY3VtZW50LnR5cGUsXG4gICAgICAgICAgICBjb21taXR0ZWU6IGRvY3VtZW50LmNvbW1pdHRlZSxcbiAgICAgICAgICAgIGNvdW50cnk6IGRvY3VtZW50LmNvdW50cnksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZmllbGRzOiAnaWQsd2ViVmlld0xpbmsnLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQuaWQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNyZWF0aW5nIEdvb2dsZSBEb2M6ICR7ZXJyb3J9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgR29vZ2xlIERvYzogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBHb29nbGUgRG9jIGJ5IGl0cyBJRFxuICAgKiBAcGFyYW0gZ29vZ2xlRG9jSWQgVGhlIElEIG9mIHRoZSBHb29nbGUgRG9jIHRvIGdldFxuICAgKiBAcmV0dXJucyBUaGUgR29vZ2xlIERvYyBtZXRhZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0R29vZ2xlRG9jKGdvb2dsZURvY0lkOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCB3aXRoIEdvb2dsZSBEcml2ZScpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cuZ2FwaS5jbGllbnQuZHJpdmUuZmlsZXMuZ2V0KHtcbiAgICAgICAgZmlsZUlkOiBnb29nbGVEb2NJZCxcbiAgICAgICAgZmllbGRzOiAnaWQsbmFtZSx3ZWJWaWV3TGluayxtb2RpZmllZFRpbWUsY2FwYWJpbGl0aWVzJyxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBnZXR0aW5nIEdvb2dsZSBEb2M6ICR7ZXJyb3J9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgR29vZ2xlIERvYzogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBHb29nbGUgRG9jJ3MgY29udGVudFxuICAgKiBAcGFyYW0gZ29vZ2xlRG9jSWQgVGhlIElEIG9mIHRoZSBHb29nbGUgRG9jIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gY29udGVudCBUaGUgbmV3IGNvbnRlbnQgb2YgdGhlIEdvb2dsZSBEb2NcbiAgICovXG4gIGFzeW5jIHVwZGF0ZUdvb2dsZURvYyhnb29nbGVEb2NJZDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuaXNBdXRoZW50aWNhdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhlbnRpY2F0ZWQgd2l0aCBHb29nbGUgRHJpdmUnKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIHZlcnNpb24uIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbixcbiAgICAgIC8vIHlvdSB3b3VsZCB1c2UgdGhlIEdvb2dsZSBEb2NzIEFQSSB0byB1cGRhdGUgdGhlIGRvY3VtZW50IGNvbnRlbnQuXG4gICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgd2UncmUganVzdCB1cGRhdGluZyB0aGUgZG9jdW1lbnQncyBtZXRhZGF0YSBoZXJlLlxuICAgICAgYXdhaXQgd2luZG93LmdhcGkuY2xpZW50LmRyaXZlLmZpbGVzLnVwZGF0ZSh7XG4gICAgICAgIGZpbGVJZDogZ29vZ2xlRG9jSWQsXG4gICAgICAgIHJlc291cmNlOiB7XG4gICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHVwZGF0aW5nIEdvb2dsZSBEb2M6ICR7ZXJyb3J9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgR29vZ2xlIERvYzogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBFeHBvcnQgYSBHb29nbGUgRG9jIHRvIGEgc3BlY2lmaWMgZm9ybWF0IChQREYsIERPQ1gpXG4gICAqIEBwYXJhbSBnb29nbGVEb2NJZCBUaGUgSUQgb2YgdGhlIEdvb2dsZSBEb2MgdG8gZXhwb3J0XG4gICAqIEBwYXJhbSBtaW1lVHlwZSBUaGUgbWltZSB0eXBlIHRvIGV4cG9ydCB0byAoZS5nLiwgJ2FwcGxpY2F0aW9uL3BkZicpXG4gICAqIEByZXR1cm5zIEEgVVJMIHRvIGRvd25sb2FkIHRoZSBleHBvcnRlZCBmaWxlXG4gICAqL1xuICBhc3luYyBleHBvcnRHb29nbGVEb2MoZ29vZ2xlRG9jSWQ6IHN0cmluZywgbWltZVR5cGU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRoZW50aWNhdGVkIHdpdGggR29vZ2xlIERyaXZlJyk7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICBgaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vZHJpdmUvdjMvZmlsZXMvJHtnb29nbGVEb2NJZH0vZXhwb3J0P21pbWVUeXBlPSR7ZW5jb2RlVVJJQ29tcG9uZW50KG1pbWVUeXBlKX1gLFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuYWNjZXNzVG9rZW59YCxcbiAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGV4cG9ydCBHb29nbGUgRG9jOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZXhwb3J0aW5nIEdvb2dsZSBEb2M6ICR7ZXJyb3J9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBleHBvcnQgR29vZ2xlIERvYzogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBXYXRjaCBmb3IgY2hhbmdlcyB0byBhIEdvb2dsZSBEb2NcbiAgICogVGhpcyBpcyBhIHBsYWNlaG9sZGVyIGZvciByZWFsLXRpbWUgc3luYyBmdW5jdGlvbmFsaXR5LlxuICAgKiBJbiBhIHByb2R1Y3Rpb24gZW52aXJvbm1lbnQsIHlvdSB3b3VsZCB1c2UgdGhlIEdvb2dsZSBEcml2ZSBBUEknc1xuICAgKiB3YXRjaCBtZXRob2Qgb3IgZXN0YWJsaXNoIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAqIFxuICAgKiBAcGFyYW0gZ29vZ2xlRG9jSWQgVGhlIElEIG9mIHRoZSBHb29nbGUgRG9jIHRvIHdhdGNoXG4gICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuIHRoZSBHb29nbGUgRG9jIGNoYW5nZXNcbiAgICogQHJldHVybnMgQSBmdW5jdGlvbiB0byBzdG9wIHdhdGNoaW5nIGZvciBjaGFuZ2VzXG4gICAqL1xuICB3YXRjaEdvb2dsZURvYyhnb29nbGVEb2NJZDogc3RyaW5nLCBjYWxsYmFjazogKGNoYW5nZXM6IGFueSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xuICAgIC8vIFRoaXMgaXMgYSBwbGFjZWhvbGRlci4gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB5b3Ugd291bGQgdXNlIHRoZSBHb29nbGUgRHJpdmUgQVBJJ3NcbiAgICAvLyBjaGFuZ2VzLndhdGNoIG1ldGhvZCBvciBlc3RhYmxpc2ggYSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgICBjb25zdCBjaGVja0ludGVydmFsID0gNTAwMDsgLy8gQ2hlY2sgZXZlcnkgNSBzZWNvbmRzXG4gICAgbGV0IGxhc3RNb2RpZmllZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgXG4gICAgY29uc3QgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignTm90IGF1dGhlbnRpY2F0ZWQgd2l0aCBHb29nbGUgRHJpdmUnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGRvYyA9IGF3YWl0IHRoaXMuZ2V0R29vZ2xlRG9jKGdvb2dsZURvY0lkKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChsYXN0TW9kaWZpZWQgIT09IG51bGwgJiYgZG9jLm1vZGlmaWVkVGltZSAhPT0gbGFzdE1vZGlmaWVkKSB7XG4gICAgICAgICAgLy8gRG9jdW1lbnQgaGFzIGNoYW5nZWRcbiAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBkb2N1bWVudElkOiBnb29nbGVEb2NJZCxcbiAgICAgICAgICAgIG1vZGlmaWVkVGltZTogZG9jLm1vZGlmaWVkVGltZSxcbiAgICAgICAgICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgeW91IHdvdWxkIGluY2x1ZGUgdGhlIGFjdHVhbCBjaGFuZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGxhc3RNb2RpZmllZCA9IGRvYy5tb2RpZmllZFRpbWU7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjaGVja2luZyBmb3IgR29vZ2xlIERvYyBjaGFuZ2VzOiAke2Vycm9yfWApO1xuICAgICAgfVxuICAgIH0sIGNoZWNrSW50ZXJ2YWwpO1xuICAgIFxuICAgIC8vIFJldHVybiBhIGZ1bmN0aW9uIHRvIHN0b3Agd2F0Y2hpbmcgZm9yIGNoYW5nZXNcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEltcG9ydCBhIGZpbGUgZnJvbSBHb29nbGUgRHJpdmVcbiAgICogQHBhcmFtIGZpbGVJZCBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gaW1wb3J0XG4gICAqIEByZXR1cm5zIFRoZSBpbXBvcnRlZCBmaWxlIGRhdGFcbiAgICovXG4gIGFzeW5jIGltcG9ydEZpbGUoZmlsZUlkOiBzdHJpbmcpOiBQcm9taXNlPHsgbmFtZTogc3RyaW5nOyBjb250ZW50OiBzdHJpbmc7IG1pbWVUeXBlOiBzdHJpbmcgfT4ge1xuICAgIGlmICghdGhpcy5pc0F1dGhlbnRpY2F0ZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCB3aXRoIEdvb2dsZSBEcml2ZScpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGZpbGUgbWV0YWRhdGFcbiAgICAgIGNvbnN0IG1ldGFkYXRhUmVzcG9uc2UgPSBhd2FpdCB3aW5kb3cuZ2FwaS5jbGllbnQuZHJpdmUuZmlsZXMuZ2V0KHtcbiAgICAgICAgZmlsZUlkLFxuICAgICAgICBmaWVsZHM6ICduYW1lLG1pbWVUeXBlJyxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCB7IG5hbWUsIG1pbWVUeXBlIH0gPSBtZXRhZGF0YVJlc3BvbnNlLnJlc3VsdDtcbiAgICAgIFxuICAgICAgLy8gR2V0IGZpbGUgY29udGVudFxuICAgICAgY29uc3QgY29udGVudFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgIGBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9kcml2ZS92My9maWxlcy8ke2ZpbGVJZH0/YWx0PW1lZGlhYCxcbiAgICAgICAge1xuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLmFjY2Vzc1Rva2VufWAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKCFjb250ZW50UmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IGZpbGUgY29udGVudDogJHtjb250ZW50UmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgbGV0IGNvbnRlbnQgPSAnJztcbiAgICAgIFxuICAgICAgaWYgKG1pbWVUeXBlID09PSAnYXBwbGljYXRpb24vdm5kLmdvb2dsZS1hcHBzLmRvY3VtZW50Jykge1xuICAgICAgICAvLyBFeHBvcnQgR29vZ2xlIERvYyB0byB0ZXh0XG4gICAgICAgIGNvbnN0IGV4cG9ydFVybCA9IGF3YWl0IHRoaXMuZXhwb3J0R29vZ2xlRG9jKGZpbGVJZCwgJ3RleHQvcGxhaW4nKTtcbiAgICAgICAgY29uc3QgZXhwb3J0UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChleHBvcnRVcmwpO1xuICAgICAgICBjb250ZW50ID0gYXdhaXQgZXhwb3J0UmVzcG9uc2UudGV4dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gR2V0IHJhdyBjb250ZW50IGZvciBvdGhlciBmaWxlIHR5cGVzXG4gICAgICAgIGNvbnRlbnQgPSBhd2FpdCBjb250ZW50UmVzcG9uc2UudGV4dCgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4geyBuYW1lLCBjb250ZW50LCBtaW1lVHlwZSB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbXBvcnRpbmcgZmlsZTogJHtlcnJvcn1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGltcG9ydCBmaWxlOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IGZpbGVzIGZyb20gR29vZ2xlIERyaXZlXG4gICAqIEBwYXJhbSBxdWVyeSBPcHRpb25hbCBzZWFyY2ggcXVlcnkgdG8gZmlsdGVyIGZpbGVzXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIEdvb2dsZSBEcml2ZSBmaWxlc1xuICAgKi9cbiAgYXN5bmMgbGlzdERyaXZlRmlsZXMocXVlcnk6IHN0cmluZyA9ICcnKSB7XG4gICAgaWYgKCF0aGlzLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRoZW50aWNhdGVkIHdpdGggR29vZ2xlIERyaXZlJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSB0aGUgR29vZ2xlIERyaXZlIEFQSSB0byBsaXN0IGZpbGVzXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5nYXBpLmNsaWVudC5kcml2ZS5maWxlcy5saXN0KHtcbiAgICAgICAgcGFnZVNpemU6IDUwLFxuICAgICAgICBmaWVsZHM6ICdmaWxlcyhpZCwgbmFtZSwgbWltZVR5cGUsIG1vZGlmaWVkVGltZSwgd2ViVmlld0xpbmspJyxcbiAgICAgICAgcTogcXVlcnkgPyBxdWVyeSA6ICd0cmFzaGVkID0gZmFsc2UnLFxuICAgICAgICBvcmRlckJ5OiAnbW9kaWZpZWRUaW1lIGRlc2MnXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coJ0dvb2dsZSBEcml2ZSBmaWxlczonLCByZXNwb25zZS5yZXN1bHQuZmlsZXMpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdC5maWxlcyB8fCBbXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbGlzdGluZyBEcml2ZSBmaWxlczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBSSBDb25mbGljdCBEZXRlY3Rpb24gU2VydmljZVxuICogXG4gKiBUaGlzIHNlcnZpY2UgaW1wbGVtZW50cyBhIGJhc2ljIEFJIGNvbmZsaWN0IGRldGVjdGlvbiBhbGdvcml0aG1cbiAqIHRvIGZsYWcgY29uZmxpY3RzIGJldHdlZW4gZG9jdW1lbnRzIG9yIGNvbnRlbnQgc2VjdGlvbnMuXG4gKiBcbiAqIEluIGEgcHJvZHVjdGlvbiBlbnZpcm9ubWVudCwgdGhpcyB3b3VsZCBpbnRlZ3JhdGUgd2l0aCBhblxuICogYWN0dWFsIE5MUCBvciBBSSBzZXJ2aWNlLlxuICovXG5leHBvcnQgY2xhc3MgQ29uZmxpY3REZXRlY3Rpb25TZXJ2aWNlIHtcbiAgLyoqXG4gICAqIERldGVjdCBjb25mbGljdHMgYmV0d2VlbiBkb2N1bWVudCBjb250ZW50IHNlY3Rpb25zXG4gICAqIEBwYXJhbSBjb250ZW50QSBGaXJzdCBjb250ZW50IHNlY3Rpb25cbiAgICogQHBhcmFtIGNvbnRlbnRCIFNlY29uZCBjb250ZW50IHNlY3Rpb25cbiAgICogQHJldHVybnMgQXJyYXkgb2YgZGV0ZWN0ZWQgY29uZmxpY3RzXG4gICAqL1xuICBkZXRlY3RDb25mbGljdHMoY29udGVudEE6IHN0cmluZywgY29udGVudEI6IHN0cmluZyk6IEFycmF5PHtcbiAgICB0eXBlOiAnZHVwbGljYXRlX2NvbnRlbnQnIHwgJ2NvbmZsaWN0aW5nX3BlcnNwZWN0aXZlJztcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgIHNlY3Rpb25zOiBzdHJpbmdbXTtcbiAgfT4ge1xuICAgIGNvbnN0IGNvbmZsaWN0czogQXJyYXk8e1xuICAgICAgdHlwZTogJ2R1cGxpY2F0ZV9jb250ZW50JyB8ICdjb25mbGljdGluZ19wZXJzcGVjdGl2ZSc7XG4gICAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgICAgc2VjdGlvbnM6IHN0cmluZ1tdO1xuICAgIH0+ID0gW107XG4gICAgXG4gICAgLy8gVGhpcyBpcyBhIHZlcnkgYmFzaWMgaW1wbGVtZW50YXRpb24gZm9yIGRlbW9uc3RyYXRpb24gcHVycG9zZXNcbiAgICBcbiAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIGNvbnRlbnQgKGV4YWN0IG1hdGNoZXMpXG4gICAgY29uc3QgcGFyYWdyYXBoc0EgPSBjb250ZW50QS5zcGxpdCgnXFxuXFxuJyk7XG4gICAgY29uc3QgcGFyYWdyYXBoc0IgPSBjb250ZW50Qi5zcGxpdCgnXFxuXFxuJyk7XG4gICAgXG4gICAgLy8gQ29tcGFyZSBwYXJhZ3JhcGhzIGZvciBleGFjdCBtYXRjaGVzIChzaW11bGF0aW5nIGR1cGxpY2F0ZSBjb250ZW50IGRldGVjdGlvbilcbiAgICBmb3IgKGNvbnN0IHBhcmFBIG9mIHBhcmFncmFwaHNBKSB7XG4gICAgICBpZiAocGFyYUEubGVuZ3RoID4gNTAgJiYgcGFyYWdyYXBoc0IuaW5jbHVkZXMocGFyYUEpKSB7XG4gICAgICAgIGNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnZHVwbGljYXRlX2NvbnRlbnQnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRHVwbGljYXRlIHBhcmFncmFwaCBkZXRlY3RlZCcsXG4gICAgICAgICAgc2VjdGlvbnM6IFtwYXJhQV0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBTaW11bGF0aW5nIGNvbmZsaWN0aW5nIHBlcnNwZWN0aXZlIGRldGVjdGlvblxuICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZCB1c2UgTkxQIHRvIGRldGVjdCBjb250cmFkaWN0b3J5IHN0YXRlbWVudHNcbiAgICBjb25zdCBrZXl3b3Jkc0EgPSB0aGlzLmV4dHJhY3RLZXl3b3Jkcyhjb250ZW50QSk7XG4gICAgY29uc3Qga2V5d29yZHNCID0gdGhpcy5leHRyYWN0S2V5d29yZHMoY29udGVudEIpO1xuICAgIFxuICAgIC8vIENoZWNrIGZvciBvcHBvc2l0ZSBzZW50aW1lbnQga2V5d29yZHMgKHZlcnkgc2ltcGxpZmllZCBhcHByb2FjaClcbiAgICBjb25zdCBvcHBvc2l0ZUtleXdvcmRzID0gW1xuICAgICAgWydzdXBwb3J0JywgJ29wcG9zZSddLFxuICAgICAgWydhZ3JlZScsICdkaXNhZ3JlZSddLFxuICAgICAgWydhcHByb3ZlJywgJ2Rpc2FwcHJvdmUnXSxcbiAgICAgIFsnaW5jcmVhc2UnLCAnZGVjcmVhc2UnXSxcbiAgICAgIFsncG9zaXRpdmUnLCAnbmVnYXRpdmUnXSxcbiAgICBdO1xuICAgIFxuICAgIGZvciAoY29uc3QgW3Bvc2l0aXZlLCBuZWdhdGl2ZV0gb2Ygb3Bwb3NpdGVLZXl3b3Jkcykge1xuICAgICAgaWYgKFxuICAgICAgICAoa2V5d29yZHNBLmluY2x1ZGVzKHBvc2l0aXZlKSAmJiBrZXl3b3Jkc0IuaW5jbHVkZXMobmVnYXRpdmUpKSB8fFxuICAgICAgICAoa2V5d29yZHNBLmluY2x1ZGVzKG5lZ2F0aXZlKSAmJiBrZXl3b3Jkc0IuaW5jbHVkZXMocG9zaXRpdmUpKVxuICAgICAgKSB7XG4gICAgICAgIGNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnY29uZmxpY3RpbmdfcGVyc3BlY3RpdmUnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgUG90ZW50aWFsbHkgY29uZmxpY3RpbmcgcG9zaXRpb25zOiBcIiR7cG9zaXRpdmV9XCIgdnMgXCIke25lZ2F0aXZlfVwiYCxcbiAgICAgICAgICBzZWN0aW9uczogdGhpcy5maW5kU2VudGVuY2VzV2l0aEtleXdvcmRzKFxuICAgICAgICAgICAgW2NvbnRlbnRBLCBjb250ZW50Ql0sXG4gICAgICAgICAgICBbcG9zaXRpdmUsIG5lZ2F0aXZlXVxuICAgICAgICAgICksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gY29uZmxpY3RzO1xuICB9XG4gIFxuICAvKipcbiAgICogRXh0cmFjdCBrZXl3b3JkcyBmcm9tIHRleHQgKHNpbXBsaWZpZWQgaW1wbGVtZW50YXRpb24pXG4gICAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IHRvIGV4dHJhY3Qga2V5d29yZHMgZnJvbVxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBleHRyYWN0ZWQga2V5d29yZHNcbiAgICovXG4gIHByaXZhdGUgZXh0cmFjdEtleXdvcmRzKHRleHQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICAvLyBUaGlzIGlzIGEgc2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbi5cbiAgICAvLyBJbiBhIHJlYWwgYXBwLCB5b3Ugd291bGQgdXNlIGEgcHJvcGVyIE5MUCBsaWJyYXJ5IGZvciBrZXl3b3JkIGV4dHJhY3Rpb24uXG4gICAgY29uc3Qgd29yZHMgPSB0ZXh0LnRvTG93ZXJDYXNlKCkuc3BsaXQoL1xcVysvKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KHdvcmRzLmZpbHRlcih3b3JkID0+IHdvcmQubGVuZ3RoID4gMykpKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEZpbmQgc2VudGVuY2VzIGNvbnRhaW5pbmcgc3BlY2lmaWMga2V5d29yZHNcbiAgICogQHBhcmFtIHRleHRzIEFycmF5IG9mIHRleHQgYmxvY2tzIHRvIHNlYXJjaCBpblxuICAgKiBAcGFyYW0ga2V5d29yZHMgS2V5d29yZHMgdG8gc2VhcmNoIGZvclxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBzZW50ZW5jZXMgY29udGFpbmluZyB0aGUga2V5d29yZHNcbiAgICovXG4gIHByaXZhdGUgZmluZFNlbnRlbmNlc1dpdGhLZXl3b3Jkcyh0ZXh0czogc3RyaW5nW10sIGtleXdvcmRzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBzZW50ZW5jZXM6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgLy8gU3BsaXQgdGV4dHMgaW50byBzZW50ZW5jZXMgYW5kIGZpbmQgdGhvc2UgY29udGFpbmluZyBrZXl3b3Jkc1xuICAgIGZvciAoY29uc3QgdGV4dCBvZiB0ZXh0cykge1xuICAgICAgY29uc3QgdGV4dFNlbnRlbmNlcyA9IHRleHQuc3BsaXQoL1suIT9dKy8pLmZpbHRlcihzID0+IHMudHJpbSgpLmxlbmd0aCA+IDApO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHNlbnRlbmNlIG9mIHRleHRTZW50ZW5jZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXl3b3JkIG9mIGtleXdvcmRzKSB7XG4gICAgICAgICAgaWYgKHNlbnRlbmNlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoa2V5d29yZC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgc2VudGVuY2VzLnB1c2goc2VudGVuY2UudHJpbSgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gc2VudGVuY2VzO1xuICB9XG59XG5cbi8vIENyZWF0ZSBzaW5nbGV0b24gaW5zdGFuY2VzIGZvciB1c2UgdGhyb3VnaG91dCB0aGUgYXBwbGljYXRpb25cbmV4cG9ydCBjb25zdCBnb29nbGVEcml2ZVNlcnZpY2UgPSBuZXcgR29vZ2xlRHJpdmVTZXJ2aWNlKCk7XG5leHBvcnQgY29uc3QgY29uZmxpY3REZXRlY3Rpb25TZXJ2aWNlID0gbmV3IENvbmZsaWN0RGV0ZWN0aW9uU2VydmljZSgpO1xuXG4vLyBBZGQgVHlwZVNjcmlwdCBpbnRlcmZhY2VzIGZvciBHb29nbGUgQVBJIHdpbmRvd3MgcmVmZXJlbmNlc1xuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBnYXBpOiBhbnk7XG4gICAgZ29vZ2xlOiBhbnk7XG4gIH1cbn0gIl0sIm5hbWVzIjpbIkRFRkFVTFRfQ09ORklHIiwiY2xpZW50SWQiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfR09PR0xFX0NMSUVOVF9JRCIsImFwaUtleSIsIk5FWFRfUFVCTElDX0dPT0dMRV9BUElfS0VZIiwic2NvcGVzIiwiR29vZ2xlRHJpdmVTZXJ2aWNlIiwiaW5pdGlhbGl6ZSIsImluaXRpYWxpemF0aW9uUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwic2NyaXB0MSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNyYyIsImFzeW5jIiwiZGVmZXIiLCJvbmxvYWQiLCJnYXBpTG9hZGVkIiwibG9hZEdhcGlDbGllbnQiLCJ0aGVuIiwiZ2lzTG9hZGVkIiwiY2F0Y2giLCJvbmVycm9yIiwiZXJyb3IiLCJjb25zb2xlIiwiRXJyb3IiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJzY3JpcHQyIiwiaW5pdGlhbGl6ZVRva2VuQ2xpZW50Iiwid2luZG93IiwiZ2FwaSIsImxvYWQiLCJjYWxsYmFjayIsImNsaWVudCIsImluaXQiLCJjb25maWciLCJkaXNjb3ZlcnlEb2NzIiwidG9rZW5DbGllbnQiLCJnb29nbGUiLCJhY2NvdW50cyIsIm9hdXRoMiIsImluaXRUb2tlbkNsaWVudCIsImNsaWVudF9pZCIsInNjb3BlIiwiam9pbiIsInRva2VuUmVzcG9uc2UiLCJhY2Nlc3NUb2tlbiIsImFjY2Vzc190b2tlbiIsInNldFRva2VuIiwiYXV0aGVudGljYXRlIiwicmVzcCIsImdldFRva2VuIiwicmVxdWVzdEFjY2Vzc1Rva2VuIiwicHJvbXB0IiwiaXNBdXRoZW50aWNhdGVkIiwiY3JlYXRlR29vZ2xlRG9jIiwicmVzcG9uc2UiLCJkcml2ZSIsImZpbGVzIiwiY3JlYXRlIiwicmVzb3VyY2UiLCJuYW1lIiwidGl0bGUiLCJtaW1lVHlwZSIsImRlc2NyaXB0aW9uIiwidHlwZSIsImNvbW1pdHRlZSIsImNvdW50cnkiLCJwcm9wZXJ0aWVzIiwibXVuQ29ubmVjdERvY0lkIiwiaWQiLCJkb2N1bWVudFR5cGUiLCJmaWVsZHMiLCJyZXN1bHQiLCJnZXRHb29nbGVEb2MiLCJnb29nbGVEb2NJZCIsImdldCIsImZpbGVJZCIsInVwZGF0ZUdvb2dsZURvYyIsImNvbnRlbnQiLCJ1cGRhdGUiLCJsYXN0VXBkYXRlZCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImV4cG9ydEdvb2dsZURvYyIsImZldGNoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJvayIsInN0YXR1c1RleHQiLCJibG9iIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwid2F0Y2hHb29nbGVEb2MiLCJjaGVja0ludGVydmFsIiwibGFzdE1vZGlmaWVkIiwiaW50ZXJ2YWxJZCIsInNldEludGVydmFsIiwid2FybiIsImRvYyIsIm1vZGlmaWVkVGltZSIsImRvY3VtZW50SWQiLCJjbGVhckludGVydmFsIiwiaW1wb3J0RmlsZSIsIm1ldGFkYXRhUmVzcG9uc2UiLCJjb250ZW50UmVzcG9uc2UiLCJleHBvcnRVcmwiLCJleHBvcnRSZXNwb25zZSIsInRleHQiLCJsaXN0RHJpdmVGaWxlcyIsInF1ZXJ5IiwibGlzdCIsInBhZ2VTaXplIiwicSIsIm9yZGVyQnkiLCJsb2ciLCJjb25zdHJ1Y3RvciIsIkNvbmZsaWN0RGV0ZWN0aW9uU2VydmljZSIsImRldGVjdENvbmZsaWN0cyIsImNvbnRlbnRBIiwiY29udGVudEIiLCJjb25mbGljdHMiLCJwYXJhZ3JhcGhzQSIsInNwbGl0IiwicGFyYWdyYXBoc0IiLCJwYXJhQSIsImxlbmd0aCIsImluY2x1ZGVzIiwicHVzaCIsInNlY3Rpb25zIiwia2V5d29yZHNBIiwiZXh0cmFjdEtleXdvcmRzIiwia2V5d29yZHNCIiwib3Bwb3NpdGVLZXl3b3JkcyIsInBvc2l0aXZlIiwibmVnYXRpdmUiLCJmaW5kU2VudGVuY2VzV2l0aEtleXdvcmRzIiwid29yZHMiLCJ0b0xvd2VyQ2FzZSIsIkFycmF5IiwiZnJvbSIsIlNldCIsImZpbHRlciIsIndvcmQiLCJ0ZXh0cyIsImtleXdvcmRzIiwic2VudGVuY2VzIiwidGV4dFNlbnRlbmNlcyIsInMiLCJ0cmltIiwic2VudGVuY2UiLCJrZXl3b3JkIiwiZ29vZ2xlRHJpdmVTZXJ2aWNlIiwiY29uZmxpY3REZXRlY3Rpb25TZXJ2aWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/googleDrive.ts\n"));

/***/ })

});